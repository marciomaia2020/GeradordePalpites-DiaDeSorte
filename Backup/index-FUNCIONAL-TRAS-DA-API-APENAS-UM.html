<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerador de Palpites Baseado em dígitos- Dia de Sorte</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                    }
                }
            },
            darkMode: 'class',
        }
    </script>
    <style>
        @media print {
            .no-print {
                display: none;
            }
            .page-break {
                page-break-after: always;
            }
        }
        
        footer {
                color: #161515;
                text-align: center;
                padding: 5px;
                margin-bottom: auto;
                margin-top: 10px; /* Espaço acima do rodapé */
        }
        .small{
                font-size: 16px;
                font-style: italic;
        }
        
        .toggle-btn {
            cursor: pointer;
            transition: transform 0.3s ease;
        }
        
        .toggle-btn.active {
            transform: rotate(180deg);
        }
        
        .transition-height {
            transition: max-height 0.5s ease-out;
            overflow: hidden;
        }
        
        .number-low {
            background-color: rgba(134, 239, 172, 0.9);
            color: rgb(22, 101, 52);
        }
        
        .dark .number-low {
            background-color: rgba(22, 101, 52, 0.7);
            color: rgb(187, 247, 208);
        }
        
        .number-medium {
            background-color: rgba(253, 230, 138, 0.9);
            color: rgb(146, 64, 14);
        }
        
        .dark .number-medium {
            background-color: rgba(146, 64, 14, 0.7);
            color: rgb(254, 240, 138);
        }
        
        .number-high {
            background-color: rgba(252, 165, 165, 0.9);
            color: rgb(153, 27, 27);
        }
        
        .dark .number-high {
            background-color: rgba(153, 27, 27, 0.7);
            color: rgb(254, 202, 202);
        }
        
        /* Estilos para exibição da frequência das dezenas */
        .frequency-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
        }
        
        .frequency-ball {
            position: relative;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            background-color: #f3f4f6;
            border: 2px solid transparent;
            color: #1f2937;
            margin: 0 auto;
        }
        
        .dark .frequency-ball {
            background-color: #374151;
            color: #f3f4f6;
        }
        
        .freq-low {
            border-color: #10b981;
        }
        
        .freq-medium {
            border-color: #f59e0b;
        }
        
        .freq-high {
            border-color: #ef4444;
        }
        
        .freq-value {
            position: absolute;
            top: -8px;
            right: -8px;
            background-color: #4b5563;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 0.7rem;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* Estilos para o mês da sorte */
        .month-ball {
            padding: 2px 6px;
            border-radius: 12px;
            background-color: #8b5cf6;
            color: white;
            font-weight: bold;
            font-size: 0.8rem;
        }
        
        .dark .month-ball {
            background-color: #7c3aed;
        }
        
        /* Destacar mês mais frequente */
        .month-highlight {
            box-shadow: 0 0 0 3px #fbbf24, 0 0 10px #fbbf24;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 2px rgba(251, 191, 36, 0.7); }
            70% { box-shadow: 0 0 0 5px rgba(251, 191, 36, 0); }
            100% { box-shadow: 0 0 0 2px rgba(251, 191, 36, 0); }
        }
        
        /* Estilos para o modal popup */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            overflow-y: auto;
        }
        
        .modal-content {
            background-color: white;
            margin: 2rem auto;
            max-width: 90%;
            width: 800px;
            border-radius: 8px;
            position: relative;
        }
        
        .dark .modal-content {
            background-color: #1f2937;
            color: #e5e7eb;
        }
        
        .modal-header {
            padding: 1rem;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .dark .modal-header {
            border-bottom: 1px solid #4b5563;
        }
        
        .modal-body {
            padding: 1.5rem;
            max-height: 70vh;
            overflow-y: auto;
        }
        
        .modal-footer {
            padding: 1rem;
            border-top: 1px solid #e2e8f0;
            text-align: right;
        }
        
        .dark .modal-footer {
            border-top: 1px solid #4b5563;
        }
        
        .close-btn {
            cursor: pointer;
            font-size: 1.5rem;
            font-weight: bold;
        }
        
        /* Animação para as barras de estatística */
        @keyframes barGrow {
            from { height: 0%; }
            to { height: var(--target-height); }
        }
        
        .stat-bar-group .stat-bar {
            animation: barGrow 1s ease-out forwards;
        }
        
        /* Spinner para carregamento */
        @keyframes spinner {
            to {transform: rotate(360deg);}
        }
        
        .spinner {
            display: inline-block;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            animation: spinner 0.8s linear infinite;
        }
    </style>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-800 dark:text-gray-200 min-h-screen">
    <!-- Dark mode detection -->
    <script>
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });
    </script>

    <!-- Modal de Instruções -->
    <div id="instructionsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="text-2xl font-bold text-primary">Como Usar o Gerador de Palpites - Dia de Sorte</h2>
                <span class="close-btn" id="closeModal">&times;</span>
            </div>
            <div class="modal-body">
                <div class="space-y-6">
                    <section>
                        <h3 class="text-xl font-semibold text-primary mb-2">Introdução</h3>
                        <p class="mb-2">Este aplicativo utiliza uma abordagem matemática para gerar palpites para a loteria Dia de Sorte, baseando-se em combinações de dígitos que ainda não foram sorteadas.</p>
                        <p>A estratégia principal é identificar quais combinações de 5 dígitos (de 0 a 9) nunca apareceram nos sorteios anteriores, maximizando suas chances ao jogar exclusivamente com estas combinações inexploradas.</p>
                    </section>
                    
                    <section>
                        <h3 class="text-xl font-semibold text-primary mb-2">Passo a Passo</h3>
                        
                        <div class="mb-4">
                            <h4 class="font-bold">1. Analisar Resultados Anteriores</h4>
                            <ul class="list-disc pl-6 mt-1 mb-2">
                                <li>Expanda a seção "Análise de Frequência de Resultados Anteriores"</li>
                                <li>Clique em "Buscar Resultados" para importar os sorteios passados automaticamente, ou</li>
                                <li>Cole manualmente os resultados na caixa de texto (cada linha deve conter os números de um sorteio)</li>
                                <li>Clique em "Analisar Frequência" para processar os dados</li>
                            </ul>
                            <p class="text-sm italic">O sistema identificará quais combinações de 5 dígitos nunca foram sorteadas. Estas serão automaticamente usadas para gerar seus palpites.</p>
                        </div>
                        
                        <div class="mb-4">
                            <h4 class="font-bold">2. Configurar Parâmetros (opcional)</h4>
                            <ul class="list-disc pl-6 mt-1 mb-2">
                                <li>Expanda a seção "Configurações"</li>
                                <li>Ajuste a quantidade de dezenas por palpite (7 a 15)</li>
                                <li>Configure a distribuição desejada de números baixos, médios e altos</li>
                            </ul>
                            <p class="text-sm italic">Recomendamos manter a configuração padrão para uma distribuição equilibrada.</p>
                        </div>
                        
                        <div class="mb-4">
                            <h4 class="font-bold">3. Gerar Palpites</h4>
                            <ul class="list-disc pl-6 mt-1 mb-2">
                                <li>Clique no botão "Gerar Palpites" na seção de Configurações</li>
                                <li>Os palpites serão gerados utilizando apenas as combinações que nunca foram sorteadas</li>
                                <li>Você pode filtrar os resultados por categoria (baixas, médias, altas) usando as abas</li>
                            </ul>
                        </div>
                        
                        <div class="mb-4">
                            <h4 class="font-bold">4. Explorar Combinações Específicas (opcional)</h4>
                            <ul class="list-disc pl-6 mt-1 mb-2">
                                <li>Expanda a seção "Gerador por Combinação Específica"</li>
                                <li>Selecione uma combinação de dígitos específica (as não sorteadas terão um ★)</li>
                                <li>Clique em "Gerar Palpites" para ver todas as combinações possíveis para aquele conjunto de dígitos</li>
                            </ul>
                        </div>
                        
                        <div class="mb-4">
                            <h4 class="font-bold">5. Exportar seus Palpites</h4>
                            <ul class="list-disc pl-6 mt-1 mb-2">
                                <li>Use o botão "Somente Dezenas" para baixar apenas os números</li>
                                <li>Use o botão "Baixar Detalhado" para um relatório completo com estatísticas</li>
                                <li>Para imprimir, use o botão "Imprimir" na seção de Configurações</li>
                            </ul>
                        </div>
                    </section>
                    
                    <section>
                        <h3 class="text-xl font-semibold text-primary mb-2">Seções da Aplicação</h3>
                        
                        <div class="mb-3">
                            <h4 class="font-bold">Combinações de Dígitos</h4>
                            <p>Mostra as combinações de 5 dígitos que serão usadas para gerar os palpites. Após a análise, mostrará apenas as combinações que nunca foram sorteadas.</p>
                        </div>
                        
                        <div class="mb-3">
                            <h4 class="font-bold">Análise de Frequência</h4>
                            <p>Permite inserir e analisar resultados anteriores, identificando quais combinações de dígitos já apareceram e quais ainda não foram sorteadas.</p>
                        </div>
                        
                        <div class="mb-3">
                            <h4 class="font-bold">Tabela de Combinações</h4>
                            <p>Mostra em detalhes todas as combinações disponíveis e quais números cada uma pode gerar.</p>
                        </div>
                        
                        <div class="mb-3">
                            <h4 class="font-bold">Resumo Estatístico</h4>
                            <p>Fornece estatísticas sobre as combinações e quantos números cada uma gera.</p>
                        </div>
                        
                        <div class="mb-3">
                            <h4 class="font-bold">Gerador por Combinação Específica</h4>
                            <p>Permite gerar todos os palpites possíveis para uma combinação específica de dígitos.</p>
                        </div>
                        
                        <div class="mb-3">
                            <h4 class="font-bold">Palpites Gerados</h4>
                            <p>Exibe todos os palpites gerados a partir das combinações selecionadas.</p>
                        </div>
                    </section>
                    
                    <section class="bg-blue-50 dark:bg-blue-900 p-4 rounded-lg">
                        <h3 class="text-xl font-semibold text-blue-700 dark:text-blue-300 mb-2">Resumo</h3>
                        <ol class="list-decimal pl-6 space-y-2 text-blue-800 dark:text-blue-200">
                            <li>Busque ou insira resultados anteriores da Dia de Sorte</li>
                            <li>Clique em "Analisar Frequência" para identificar combinações não sorteadas</li>
                            <li>Ajuste as configurações conforme desejado (quantidade de dezenas, distribuição)</li>
                            <li>Clique em "Gerar Palpites" para criar jogos baseados apenas nas combinações nunca sorteadas</li>
                            <li>Exporte seus palpites usando os botões de download ou impressão</li>
                        </ol>
                        <p class="mt-4 font-bold text-blue-700 dark:text-blue-300">Jogando apenas com combinações que nunca apareceram, você estará apostando em padrões matemáticos ainda não explorados nos sorteios!</p>
                    </section>
                </div>
            </div>
            <div class="modal-footer">
                <button id="closeModalBtn" class="bg-primary hover:bg-primary/90 text-white py-2 px-6 rounded">Entendi</button>
            </div>
        </div>
    </div>

    <div class="container mx-auto px-4 py-8">
        <div class="flex justify-between items-center mb-6">
            <h1 class="text-3xl font-bold text-center text-primary">Gerador de Palpites - Dia de Sorte <span><a href="Selecao-De-Digitos.html">Seleção de  Dígitos</a></span></h1> 
            <button id="showInstructionsBtn" class="bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-200 py-2 px-4 rounded flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd" />
                </svg>
                Como Usar
            </button>
        </div>
        
        <!-- Seção: Combinações de Dígitos -->
        <div class="mb-6">
            <div class="flex items-center justify-between cursor-pointer mb-2" id="digitCombinationsHeader">
                <h2 class="text-xl font-semibold flex items-center">
                    <span>Combinações de Dígitos</span> 
                    <span class="text-sm font-bold ml-2 bg-blue-100 dark:bg-blue-800 text-blue-800 dark:text-blue-200 px-2 py-0.5 rounded-full">(126)</span>
                </h2>
                <svg class="h-6 w-6 text-gray-500 dark:text-gray-400 toggle-btn" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                </svg>
            </div>
            <div id="digitCombinationsContainer" class="transition-height bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded p-4" style="max-height: 0px; overflow: hidden;">
                <textarea id="digitCombinations" rows="6" class="w-full p-2 border rounded dark:bg-gray-800 dark:border-gray-700 text-base" readonly></textarea>
            </div>
        </div>
        
        <!-- Seção: Configurações -->
        <div class="mb-6">
            <div class="flex items-center justify-between cursor-pointer mb-2" id="configHeader">
                <h2 class="text-xl font-semibold">Configurações</h2>
                <svg class="h-6 w-6 text-gray-500 dark:text-gray-400 toggle-btn" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                </svg>
            </div>
            <div id="configContainer" class="transition-height bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded" style="max-height: 500px; overflow: hidden;">
                <div class="space-y-4 bg-gray-100 dark:bg-gray-800 p-4 rounded">
                    <div>
                        <label class="block mb-1">Quantidade de dezenas por palpite:</label>
                        <input type="number" id="numberPerBet" value="7" min="7" max="15" class="p-2 border rounded w-full dark:bg-gray-700 dark:border-gray-600 text-base">
                    </div>
                    <!-- Campo de número máximo removido, agora é fixo em 31 e oculto -->
                    <input type="hidden" id="maxNumber" value="31">
                    <div>
                        <label class="block mb-1">Distribuição por faixa:</label>
                        <div class="flex flex-wrap gap-2">
                            <div class="flex items-center gap-1">
                                <label for="lowRange" class="whitespace-nowrap">Baixas (1-10):</label>
                                <input type="number" id="lowRange" value="3" min="0" max="15" class="p-2 border rounded w-14 dark:bg-gray-700 dark:border-gray-600 text-base">
                            </div>
                            <div class="flex items-center gap-1">
                                <label for="mediumRange" class="whitespace-nowrap">Médias (11-20):</label>
                                <input type="number" id="mediumRange" value="3" min="0" max="15" class="p-2 border rounded w-14 dark:bg-gray-700 dark:border-gray-600 text-base">
                            </div>
                            <div class="flex items-center gap-1">
                                <label for="highRange" class="whitespace-nowrap">Altas (21-31):</label>
                                <input type="number" id="highRange" value="1" min="0" max="15" class="p-2 border rounded w-14 dark:bg-gray-700 dark:border-gray-600 text-base">
                            </div>
                        </div>
                        <div id="distributionSummary" class="text-sm mt-1 mb-2 text-gray-600 dark:text-gray-400"></div>
                    </div>
                    <div class="flex gap-2 mt-4">
                        <button id="generateBtn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-medium py-2 px-6 rounded">
                            Gerar Palpites
                        </button>
                        <button id="printBtn" class="bg-gray-500 hover:bg-gray-600 text-white font-medium py-2 px-6 rounded">
                            Imprimir
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Seção: Análise de Frequência -->
        <div class="mb-6">
            <div class="flex items-center justify-between cursor-pointer mb-2" id="frequencyHeader">
                <h2 class="text-xl font-semibold">Análise de Frequência de Resultados Anteriores</h2>
                <svg class="h-6 w-6 text-gray-500 dark:text-gray-400 toggle-btn" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                </svg>
            </div>
            <div id="frequencyContainer" class="transition-height bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded" style="max-height: 500px; overflow: hidden;">
                <div class="p-4">
                    <div class="mb-4">
                        <label class="block mb-1">Cole os resultados do Dia de Sorte (um por linha, números separados por espaço):</label>
                        <textarea id="historicalResults" rows="6" placeholder="Ex: 01 03 07 13 18 27 29 Jan
04 07 09 10 14 20 25 Fev" class="w-full p-2 border rounded dark:bg-gray-800 dark:border-gray-700 text-base"></textarea>
                        <div class="text-xs text-gray-500 dark:text-gray-400 mt-1">
                            Formato: "01 02 03 04 05 06 07 Jan" (incluindo o mês da sorte ao final se disponível)
                        </div>
                    </div>
                    <div class="flex flex-wrap gap-2 mb-4">
                        <button id="analyzeBtn" class="bg-primary hover:bg-primary/90 text-white font-bold py-2 px-4 rounded">
                            Analisar Frequência
                        </button>
                        <div class="flex flex-col sm:flex-row gap-2 flex-grow">
                            <select id="apiSelect" class="p-2 border rounded dark:bg-gray-700 dark:border-gray-600 text-base flex-grow">
                                <option value="auto">Auto (Testar Todas as APIs)</option>
                                <option value="caixa">API Caixa Oficial</option>
                                <option value="heroku">API Heroku</option>
                                <option value="brasilapi">API Brasil</option>
                            </select>
                            <select id="modeSelect" class="p-2 border rounded dark:bg-gray-700 dark:border-gray-600 text-base">
                                <option value="direct">Acesso Direto</option>
                                <option value="proxy">Via Proxy CORS</option>
                                <option value="both">Tentar Ambos</option>
                            </select>
                        </div>
                        <div class="flex items-center">
                            <input type="checkbox" id="forceRefresh" class="mr-2 w-4 h-4">
                            <label for="forceRefresh" class="text-sm">Forçar atualização (ignorar cache)</label>
                        </div>
                        <input type="number" id="concursoNum" placeholder="Nº do concurso (opcional)" min="1" class="p-2 border rounded dark:bg-gray-700 dark:border-gray-600 text-base w-48">
                        <div class="flex gap-2">
                            <button id="fetchResultsBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded flex items-center">
                                <span id="fetchText">Buscar Resultados</span>
                                <span id="loadingSpinner" class="spinner ml-2 hidden"></span>
                            </button>
                            <button id="fetchAllResultsBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded flex items-center">
                                <span>Buscar Todos</span>
                                <span id="loadingAllSpinner" class="spinner ml-2 hidden"></span>
                            </button>
                        </div>
                    </div>
                    <div id="apiStatus" class="mb-4 p-3 bg-gray-100 dark:bg-gray-700 rounded hidden">
                        <div class="font-semibold mb-1">Status da busca:</div>
                        <div id="apiStatusContent" class="text-sm"></div>
                    </div>
                    <div id="frequencyAnalysis" class="mt-4">
                        <div id="frequencyResults" class="hidden">
                            <h3 class="text-lg font-semibold mb-2">Frequência de Dígitos</h3>
                            <div id="topCombinations" class="bg-gray-100 dark:bg-gray-700 p-3 rounded mb-3">
                                <!-- Será preenchido com as combinações mais frequentes -->
                            </div>
                            
                            <!-- NOVA SEÇÃO: Estatística de dezenas por categoria -->
                            <div id="numberCategoryStats" class="bg-indigo-900 p-3 rounded mb-3 text-center">
                                <div class="font-bold text-xl mb-3 text-white">Estatística de Dezenas nos Sorteios Anteriores</div>
                                <div class="stat-bars-container flex justify-center items-end h-20 mb-1 gap-4">
                                    <div class="stat-bar-group flex flex-col items-center">
                                        <div id="lowBar" class="bg-green-500 w-32 text-white font-bold flex justify-center items-center" style="height: 0%">57%</div>
                                        <div class="text-sm text-white mt-1">4 dezenas<br>baixas</div>
                                    </div>
                                    <div class="stat-bar-group flex flex-col items-center">
                                        <div id="mediumBar" class="bg-yellow-600 w-32 text-white font-bold flex justify-center items-center" style="height: 0%">14%</div>
                                        <div class="text-sm text-white mt-1">1 dezenas<br>Médias</div>
                                    </div>
                                    <div class="stat-bar-group flex flex-col items-center">
                                        <div id="highBar" class="bg-red-600 w-32 text-white font-bold flex justify-center items-center" style="height: 0%">29%</div>
                                        <div class="text-sm text-white mt-1">2 dezenas<br>Altas</div>
                                    </div>
                                </div>
                                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mt-3 mb-3">
                                    <div class="bg-green-800 p-3 rounded-lg text-left">
                                        <div class="font-bold text-white">Baixas (1-10)</div>
                                        <div id="lowNumberStats" class="text-green-200"></div>
                                    </div>
                                    <div class="bg-yellow-700 p-3 rounded-lg text-left">
                                        <div class="font-bold text-white">Médias (11-20)</div>
                                        <div id="mediumNumberStats" class="text-yellow-200"></div>
                                    </div>
                                    <div class="bg-red-800 p-3 rounded-lg text-left">
                                        <div class="font-bold text-white">Altas (21-31)</div>
                                        <div id="highNumberStats" class="text-red-200"></div>
                                    </div>
                                </div>
                                <div class="text-sm text-gray-300 italic">
                                    Esta estatística mostra a frequência de cada categoria de dezenas nos sorteios analisados.
                                    Use-a para ajustar sua estratégia de distribuição.
                                </div>
                            </div>
                            
                            <!-- NOVA SEÇÃO: Frequência por dezena -->
                            <div id="numberFrequencyStats" class="bg-purple-900 p-3 rounded mb-3">
                                <div class="font-bold text-xl mb-3 text-white">Frequência de Cada Dezena</div>
                                <div id="numberFrequencyGrid" class="frequency-grid gap-3 mb-3">
                                    <!-- Será preenchido dinamicamente com as dezenas e suas frequências -->
                                </div>
                                <div class="text-sm text-gray-300 italic text-center mt-2">
                                    Esta estatística mostra quantas vezes cada dezena apareceu nos sorteios analisados.
                                    Os números mais frequentes estão destacados em vermelho.
                                </div>
                            </div>
                            
                            <!-- NOVA SEÇÃO: Frequência dos meses da sorte -->
                            <div id="monthFrequencyStats" class="bg-indigo-800 p-3 rounded mb-3">
                                <div class="font-bold text-xl mb-3 text-white">Frequência do Mês da Sorte</div>
                                <div class="grid grid-cols-2 md:grid-cols-4 gap-3 mb-3">
                                    <div id="monthJan" class="bg-indigo-700 rounded p-2 text-center">
                                        <div class="text-lg font-bold text-white">Janeiro</div>
                                        <div class="text-2xl text-yellow-300">0</div>
                                        <div class="text-sm text-indigo-200">0.0%</div>
                                    </div>
                                    <div id="monthFev" class="bg-indigo-700 rounded p-2 text-center">
                                        <div class="text-lg font-bold text-white">Fevereiro</div>
                                        <div class="text-2xl text-yellow-300">0</div>
                                        <div class="text-sm text-indigo-200">0.0%</div>
                                    </div>
                                    <div id="monthMar" class="bg-indigo-700 rounded p-2 text-center">
                                        <div class="text-lg font-bold text-white">Março</div>
                                        <div class="text-2xl text-yellow-300">0</div>
                                        <div class="text-sm text-indigo-200">0.0%</div>
                                    </div>
                                    <div id="monthAbr" class="bg-indigo-700 rounded p-2 text-center">
                                        <div class="text-lg font-bold text-white">Abril</div>
                                        <div class="text-2xl text-yellow-300">0</div>
                                        <div class="text-sm text-indigo-200">0.0%</div>
                                    </div>
                                    <div id="monthMai" class="bg-indigo-700 rounded p-2 text-center">
                                        <div class="text-lg font-bold text-white">Maio</div>
                                        <div class="text-2xl text-yellow-300">0</div>
                                        <div class="text-sm text-indigo-200">0.0%</div>
                                    </div>
                                    <div id="monthJun" class="bg-indigo-700 rounded p-2 text-center">
                                        <div class="text-lg font-bold text-white">Junho</div>
                                        <div class="text-2xl text-yellow-300">0</div>
                                        <div class="text-sm text-indigo-200">0.0%</div>
                                    </div>
                                    <div id="monthJul" class="bg-indigo-700 rounded p-2 text-center">
                                        <div class="text-lg font-bold text-white">Julho</div>
                                        <div class="text-2xl text-yellow-300">0</div>
                                        <div class="text-sm text-indigo-200">0.0%</div>
                                    </div>
                                    <div id="monthAgo" class="bg-indigo-700 rounded p-2 text-center">
                                        <div class="text-lg font-bold text-white">Agosto</div>
                                        <div class="text-2xl text-yellow-300">0</div>
                                        <div class="text-sm text-indigo-200">0.0%</div>
                                    </div>
                                    <div id="monthSet" class="bg-indigo-700 rounded p-2 text-center">
                                        <div class="text-lg font-bold text-white">Setembro</div>
                                        <div class="text-2xl text-yellow-300">0</div>
                                        <div class="text-sm text-indigo-200">0.0%</div>
                                    </div>
                                    <div id="monthOut" class="bg-indigo-700 rounded p-2 text-center">
                                        <div class="text-lg font-bold text-white">Outubro</div>
                                        <div class="text-2xl text-yellow-300">0</div>
                                        <div class="text-sm text-indigo-200">0.0%</div>
                                    </div>
                                    <div id="monthNov" class="bg-indigo-700 rounded p-2 text-center">
                                        <div class="text-lg font-bold text-white">Novembro</div>
                                        <div class="text-2xl text-yellow-300">0</div>
                                        <div class="text-sm text-indigo-200">0.0%</div>
                                    </div>
                                    <div id="monthDez" class="bg-indigo-700 rounded p-2 text-center">
                                        <div class="text-lg font-bold text-white">Dezembro</div>
                                        <div class="text-2xl text-yellow-300">0</div>
                                        <div class="text-sm text-indigo-200">0.0%</div>
                                    </div>
                                </div>
                                <div class="text-sm text-gray-300 italic text-center">
                                    Estatística dos meses da sorte que mais aparecem nos sorteios anteriores.
                                </div>
                            </div>
                            
                            <!-- Novo painel para combinações não sorteadas -->
                            <div id="undrawnCombinations" class="bg-blue-100 dark:bg-blue-900 p-3 rounded mb-3">
                                <div class="font-bold text-xl mb-3 text-blue-800 dark:text-blue-200 flex items-center">
                                    Combinações Ainda Não Sorteadas
                                    <span class="text-sm font-bold ml-2 bg-blue-200 dark:bg-blue-700 text-blue-800 dark:text-blue-200 px-2 py-0.5 rounded-full" id="undrawnCountDisplay"></span>
                                </div>
                                <div id="undrawnCombinationsContent" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-2">
                                    <!-- Será preenchido com as combinações não sorteadas -->
                                </div>
                                <div class="mt-3 flex justify-end">
                                    <button id="downloadUndrawnBtn" class="bg-blue-600 hover:bg-blue-700 text-white text-sm font-bold py-1 px-3 rounded">
                                        Baixar Lista
                                    </button>
                                </div>
                            </div>
                            
                            <div class="overflow-x-auto">
                                <table class="min-w-full divide-y divide-gray-300 dark:divide-gray-700">
                                    <thead>
                                        <tr class="bg-gray-100 dark:bg-gray-700">
                                            <th class="px-2 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Combinação de Dígitos</th>
                                            <th class="px-2 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Frequência</th>
                                            <th class="px-2 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Porcentagem</th>
                                        </tr>
                                    </thead>
                                    <tbody id="frequencyTableBody" class="divide-y divide-gray-200 dark:divide-gray-700">
                                        <!-- Será preenchido dinamicamente -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Seção: Tabela de Combinações -->
        <div class="mb-8">
            <div class="flex items-center justify-between cursor-pointer mb-2" id="combinationsToggleHeader">
                <h2 class="text-xl font-semibold">Tabela de Combinações</h2>
                <svg class="h-6 w-6 text-gray-500 dark:text-gray-400 toggle-btn" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                </svg>
            </div>
            <div id="combinationsTableContainer" class="transition-height bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded overflow-x-auto" style="max-height: 0px;">
                <div id="combinationsTable">
                    <table class="min-w-full divide-y divide-gray-300 dark:divide-gray-700">
                        <thead>
                            <tr class="bg-gray-100 dark:bg-gray-700">
                                <th class="px-2 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Dígitos</th>
                                <th class="px-2 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Números Possíveis</th>
                                <th class="px-2 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Total</th>
                            </tr>
                        </thead>
                        <tbody id="combinationsTableBody" class="divide-y divide-gray-200 dark:divide-gray-700">
                            <!-- Dynamic content will be inserted here -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Seção: Resumo Estatístico -->
        <div class="mb-8">
            <div class="flex items-center justify-between cursor-pointer mb-2" id="statsHeader">
                <h2 class="text-xl font-semibold">Resumo Estatístico</h2>
                <svg class="h-6 w-6 text-gray-500 dark:text-gray-400 toggle-btn" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                </svg>
            </div>
            <div id="statsContainer" class="transition-height bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded" style="max-height: 0px; overflow: hidden;">
                <div id="statisticsSummary" class="p-4">
                    <div id="statisticsContent" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        <!-- Dynamic content will be inserted here -->
                    </div>
                    <div id="statisticsTotal" class="mt-4 font-bold border-t pt-2 dark:border-gray-700">
                        <!-- Total will be inserted here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Seção: Gerador por Combinação Específica -->
        <div class="mb-8">
            <div class="flex items-center justify-between cursor-pointer mb-2" id="specificHeader">
                <h2 class="text-xl font-semibold">Gerador por Combinação Específica</h2>
                <svg class="h-6 w-6 text-gray-500 dark:text-gray-400 toggle-btn" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                </svg>
            </div>
            <div id="specificContainer" class="transition-height bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded" style="max-height: 0px; overflow: hidden;">
                <div class="p-4">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                        <div>
                            <label class="block mb-2">Selecione uma combinação de dígitos:</label>
                            <select id="specificCombination" class="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 text-base">
                                <!-- Será preenchido dinamicamente -->
                            </select>
                        </div>
                        <div>
                            <label class="block mb-2">Dezenas por palpite:</label>
                            <div class="flex gap-4">
                                <input type="number" id="specificNumberPerBet" value="7" min="5" max="15" class="p-2 border rounded w-full dark:bg-gray-700 dark:border-gray-600 text-base">
                                <button id="generateSpecificBtn" class="bg-primary hover:bg-primary/90 text-white font-bold py-2 px-4 rounded whitespace-nowrap">
                                    Gerar Palpites
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="mb-4">
                        <div class="bg-gray-100 dark:bg-gray-700 p-3 rounded">
                            <div class="flex items-center mb-2">
                                <span class="font-semibold mr-2">Dezenas possíveis para esta combinação:</span>
                                <span id="possibleNumberCount" class="bg-primary text-white px-3 py-1 rounded-full font-bold">0</span>
                            </div>
                            <div id="possibleNumbersDisplay" class="flex flex-wrap gap-2"></div>
                        </div>
                    </div>

                    <div class="mb-4 flex flex-wrap gap-2 justify-between items-center">
                        <div>
                            <span class="font-semibold">Total de palpites gerados: </span>
                            <span id="specificBetCount" class="bg-primary/10 dark:bg-primary/20 text-primary px-2 py-1 rounded-full font-bold">0</span>
                        </div>
                        <div class="flex gap-2">
                            <button id="downloadSpecificSimpleBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded flex items-center disabled:opacity-50 disabled:cursor-not-allowed">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" />
                                </svg>
                                Somente Dezenas
                            </button>
                            <button id="downloadSpecificBtn" class="bg-primary hover:bg-primary/90 text-white font-bold py-2 px-4 rounded flex items-center disabled:opacity-50 disabled:cursor-not-allowed">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" />
                                </svg>
                                Baixar Detalhado
                            </button>
                        </div>
                    </div>

                    <div id="specificBetsResults" class="border-t dark:border-gray-700 pt-4">
                        <div id="specificResultsContainer" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                            <!-- Resultados dinâmicos serão mostrados aqui -->
                        </div>
                        
                        <!-- Paginação -->
                        <div id="paginationContainer" class="mt-6 flex justify-center items-center space-x-2">
                            <button id="prevPageBtn" class="bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-200 font-bold py-2 px-4 rounded disabled:opacity-50 disabled:cursor-not-allowed">
                                Anterior
                            </button>
                            <span id="paginationInfo" class="text-sm px-2">Página 1 de 1</span>
                            <button id="nextPageBtn" class="bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-200 font-bold py-2 px-4 rounded disabled:opacity-50 disabled:cursor-not-allowed">
                                Próxima
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Seção: Palpites Gerados -->
        <div class="mb-8">
            <div class="flex items-center justify-between cursor-pointer mb-2" id="resultsHeader">
                <h2 class="text-xl font-semibold">Palpites Gerados (<span id="totalBetsCount">0</span> palpites)</h2>
                <svg class="h-6 w-6 text-gray-500 dark:text-gray-400 toggle-btn" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                </svg>
            </div>
            <div id="resultsContainer" class="transition-height bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded" style="max-height: 500px; overflow: hidden;">
                <div class="p-4">
                    <div class="mb-4 flex flex-wrap gap-2 justify-between items-center">
                        <div class="flex flex-wrap gap-2">
                            <div class="bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200 px-3 py-1 rounded-full text-sm font-medium">
                                Baixas (1-10): <span id="lowCount">0</span>
                            </div>
                            <div class="bg-yellow-100 dark:bg-yellow-900 text-yellow-800 dark:text-yellow-200 px-3 py-1 rounded-full text-sm font-medium">
                                Médias (11-20): <span id="mediumCount">0</span>
                            </div>
                            <div class="bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-200 px-3 py-1 rounded-full text-sm font-medium">
                                Altas (21-31): <span id="highCount">0</span>
                            </div>
                        </div>
                        <div class="flex gap-2">
                            <button id="downloadSimpleBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded flex items-center">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" />
                                </svg>
                                Somente Dezenas
                            </button>
                            <button id="downloadBtn" class="bg-primary hover:bg-primary/90 text-white font-bold py-2 px-4 rounded flex items-center">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" />
                                </svg>
                                Baixar Detalhado
                            </button>
                        </div>
                    </div>
                    
                    <div class="mb-4">
                        <div class="flex border-b dark:border-gray-700">
                            <button id="allBetsTab" class="py-2 px-4 font-medium border-b-2 border-primary text-primary">Todos</button>
                            <button id="lowBetsTab" class="py-2 px-4 font-medium text-gray-600 dark:text-gray-400">Baixas</button>
                            <button id="mediumBetsTab" class="py-2 px-4 font-medium text-gray-600 dark:text-gray-400">Médias</button>
                            <button id="highBetsTab" class="py-2 px-4 font-medium text-gray-600 dark:text-gray-400">Altas</button>
                        </div>
                    </div>
                    
                    <div id="bettingResults" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        <!-- Dynamic content will be inserted here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Modal functions
            const modal = document.getElementById('instructionsModal');
            const showModalBtn = document.getElementById('showInstructionsBtn');
            const closeModalBtn = document.getElementById('closeModalBtn');
            const closeModalX = document.getElementById('closeModal');
            
            // Show modal
            showModalBtn.addEventListener('click', function() {
                modal.style.display = 'block';
                document.body.style.overflow = 'hidden'; // Prevent scrolling behind modal
            });
            
            // Close modal with button
            closeModalBtn.addEventListener('click', function() {
                modal.style.display = 'none';
                document.body.style.overflow = 'auto'; // Re-enable scrolling
            });
            
            // Close modal with X
            closeModalX.addEventListener('click', function() {
                modal.style.display = 'none';
                document.body.style.overflow = 'auto'; // Re-enable scrolling
            });
            
            // Close modal when clicking outside
            window.addEventListener('click', function(event) {
                if (event.target === modal) {
                    modal.style.display = 'none';
                    document.body.style.overflow = 'auto'; // Re-enable scrolling
                }
            });
            
            // Função para gerenciar a distribuição por faixa
            function setupRangeDistribution() {
                const numberPerBetInput = document.getElementById('numberPerBet');
                const lowRangeInput = document.getElementById('lowRange');
                const mediumRangeInput = document.getElementById('mediumRange');
                const highRangeInput = document.getElementById('highRange');
                
                // Variável para armazenar o último campo modificado
                let lastModified = null;
                
                // Função para ajustar os valores mantendo a soma igual ao total
                function adjustValues(changedInput) {
                    // Armazenar o último campo alterado
                    lastModified = changedInput;
                    
                    const targetTotal = parseInt(numberPerBetInput.value);
                    
                    // Limitar os valores aos limites permitidos (0 a targetTotal)
                    let lowVal = Math.max(0, Math.min(targetTotal, parseInt(lowRangeInput.value) || 0));
                    let mediumVal = Math.max(0, Math.min(targetTotal, parseInt(mediumRangeInput.value) || 0));
                    let highVal = Math.max(0, Math.min(targetTotal, parseInt(highRangeInput.value) || 0));
                    
                    // Atualizar os valores nos campos se foram corrigidos
                    lowRangeInput.value = lowVal;
                    mediumRangeInput.value = mediumVal;
                    highRangeInput.value = highVal;
                    
                    const currentTotal = lowVal + mediumVal + highVal;
                    
                    // Se o total já está correto, não precisa ajustar
                    if (currentTotal === targetTotal) {
                        updateDistributionSummary();
                        return;
                    }
                    
                    // Determinar qual ajuste é necessário
                    const difference = targetTotal - currentTotal;
                    
                    // Prioridade de ajuste: manter o valor do último campo alterado
                    if (changedInput === numberPerBetInput) {
                        // Se mudar o número total de dezenas, ajustar proporcionalmente todos os campos
                        if (currentTotal === 0) {
                            // Se todos estão zerados, colocar tudo em baixas
                            lowRangeInput.value = targetTotal;
                            mediumRangeInput.value = 0;
                            highRangeInput.value = 0;
                        } else {
                            // Distribuição proporcional
                            const factor = targetTotal / currentTotal;
                            
                            // Calcular novos valores mantendo proporções aproximadas
                            let newLow = Math.round(lowVal * factor);
                            let newMedium = Math.round(mediumVal * factor);
                            let newHigh = targetTotal - newLow - newMedium;
                            
                            // Ajustar se necessário para garantir valores não negativos
                            newLow = Math.max(0, newLow);
                            newMedium = Math.max(0, newMedium);
                            newHigh = Math.max(0, newHigh);
                            
                            // Garantir que a soma seja exatamente igual ao alvo
                            const adjustedTotal = newLow + newMedium + newHigh;
                            if (adjustedTotal !== targetTotal) {
                                // Ajustar o último valor para garantir a soma correta
                                newHigh = targetTotal - newLow - newMedium;
                            }
                            
                            // Aplicar os novos valores
                            lowRangeInput.value = newLow;
                            mediumRangeInput.value = newMedium;
                            highRangeInput.value = newHigh;
                        }
                    } 
                    else if (changedInput === lowRangeInput) {
                        // Se o usuário aumentou além do permitido, os outros campos serão zerados
                        if (lowVal >= targetTotal) {
                            mediumRangeInput.value = 0;
                            highRangeInput.value = 0;
                            
                            // Garantir que o total seja exato
                            lowRangeInput.value = targetTotal;
                        } else {
                            // Distribuir a diferença entre os outros campos, proporcionalmente
                            const remainingTotal = mediumVal + highVal;
                            if (remainingTotal === 0) {
                                // Se os outros campos estão zerados, colocar tudo em um deles
                                mediumRangeInput.value = 0;
                                highRangeInput.value = targetTotal - lowVal;
                            } else {
                                // Proporção atual entre médio e alto
                                const mediumRatio = mediumVal / remainingTotal;
                                
                                // Calcular novos valores
                                const remaining = targetTotal - lowVal;
                                const newMedium = Math.round(remaining * mediumRatio);
                                const newHigh = remaining - newMedium;
                                
                                // Aplicar os novos valores
                                mediumRangeInput.value = newMedium;
                                highRangeInput.value = newHigh;
                            }
                        }
                    } 
                    else if (changedInput === mediumRangeInput) {
                        // Se o usuário aumentou além do permitido, os outros campos serão zerados
                        if (mediumVal >= targetTotal) {
                            lowRangeInput.value = 0;
                            highRangeInput.value = 0;
                            
                            // Garantir que o total seja exato
                            mediumRangeInput.value = targetTotal;
                        } else {
                            // Distribuir a diferença entre os outros campos, proporcionalmente
                            const remainingTotal = lowVal + highVal;
                            if (remainingTotal === 0) {
                                // Se os outros campos estão zerados, colocar tudo em um deles
                                lowRangeInput.value = targetTotal - mediumVal;
                                highRangeInput.value = 0;
                            } else {
                                // Proporção atual entre baixo e alto
                                const lowRatio = lowVal / remainingTotal;
                                
                                // Calcular novos valores
                                const remaining = targetTotal - mediumVal;
                                const newLow = Math.round(remaining * lowRatio);
                                const newHigh = remaining - newLow;
                                
                                // Aplicar os novos valores
                                lowRangeInput.value = newLow;
                                highRangeInput.value = newHigh;
                            }
                        }
                    } 
                    else if (changedInput === highRangeInput) {
                        // Se o usuário aumentou além do permitido, os outros campos serão zerados
                        if (highVal >= targetTotal) {
                            lowRangeInput.value = 0;
                            mediumRangeInput.value = 0;
                            
                            // Garantir que o total seja exato
                            highRangeInput.value = targetTotal;
                        } else {
                            // Distribuir a diferença entre os outros campos, proporcionalmente
                            const remainingTotal = lowVal + mediumVal;
                            if (remainingTotal === 0) {
                                // Se os outros campos estão zerados, colocar tudo em um deles
                                lowRangeInput.value = targetTotal - highVal;
                                mediumRangeInput.value = 0;
                            } else {
                                // Proporção atual entre baixo e médio
                                const lowRatio = lowVal / remainingTotal;
                                
                                // Calcular novos valores
                                const remaining = targetTotal - highVal;
                                const newLow = Math.round(remaining * lowRatio);
                                const newMedium = remaining - newLow;
                                
                                // Aplicar os novos valores
                                lowRangeInput.value = newLow;
                                mediumRangeInput.value = newMedium;
                            }
                        }
                    }
                    
                    // Verificar novamente se o total está correto após ajustes
                    const finalLow = parseInt(lowRangeInput.value) || 0;
                    const finalMedium = parseInt(mediumRangeInput.value) || 0;
                    const finalHigh = parseInt(highRangeInput.value) || 0;
                    const finalTotal = finalLow + finalMedium + finalHigh;
                    
                    if (finalTotal !== targetTotal) {
                        // Ajuste final se necessário
                        const finalDiff = targetTotal - finalTotal;
                        
                        // Ajustar o campo que não foi modificado pelo usuário
                        if (changedInput !== lowRangeInput && finalLow + finalDiff >= 0) {
                            lowRangeInput.value = finalLow + finalDiff;
                        } else if (changedInput !== mediumRangeInput && finalMedium + finalDiff >= 0) {
                            mediumRangeInput.value = finalMedium + finalDiff;
                        } else if (changedInput !== highRangeInput && finalHigh + finalDiff >= 0) {
                            highRangeInput.value = finalHigh + finalDiff;
                        }
                    }
                    
                    // Atualizar a descrição na interface
                    updateDistributionSummary();
                }
                
                // Função para mostrar um resumo da distribuição atual
                function updateDistributionSummary() {
                    const totalDezenas = parseInt(numberPerBetInput.value);
                    const lowVal = parseInt(lowRangeInput.value) || 0;
                    const mediumVal = parseInt(mediumRangeInput.value) || 0;
                    const highVal = parseInt(highRangeInput.value) || 0;
                    
                    const distributionSummary = document.getElementById('distributionSummary');
                    if (distributionSummary) {
                        distributionSummary.textContent = `Total: ${lowVal + mediumVal + highVal}/${totalDezenas} dezenas`;
                        
                        // Destacar se a soma não estiver correta (não deve acontecer com o auto-ajuste)
                        if (lowVal + mediumVal + highVal !== totalDezenas) {
                            distributionSummary.classList.add('text-red-500');
                        } else {
                            distributionSummary.classList.remove('text-red-500');
                        }
                    }
                }
                
                // Adicionar event listeners
                lowRangeInput.addEventListener('change', () => adjustValues(lowRangeInput));
                mediumRangeInput.addEventListener('change', () => adjustValues(mediumRangeInput));
                highRangeInput.addEventListener('change', () => adjustValues(highRangeInput));
                numberPerBetInput.addEventListener('change', () => adjustValues(numberPerBetInput));
                
                // Também ajustar quando o usuário digita
                lowRangeInput.addEventListener('input', () => adjustValues(lowRangeInput));
                mediumRangeInput.addEventListener('input', () => adjustValues(mediumRangeInput));
                highRangeInput.addEventListener('input', () => adjustValues(highRangeInput));
                
                // Inicializar o resumo da distribuição
                updateDistributionSummary();
            }
            
            // Configurações das APIs
            const API_CONFIG = {
                // APIs oficiais
                CAIXA_URL: 'https://servicebus2.caixa.gov.br/portaldeloterias/api/diadesorte',
                HEROKU_URL: 'https://loteriascaixa-api.herokuapp.com/api/dia-de-sorte',
                BRASIL_URL: 'https://brasilapi.com.br/api/loterias/v1/dia-de-sorte',
                
                // Serviços de proxy CORS alternativos - Adicionados mais proxies
                CORS_PROXY_URLS: [
                    'https://corsproxy.io/?',
                    'https://api.allorigins.win/raw?url=',
                    'https://cors-anywhere.herokuapp.com/',
                    'https://proxy.cors.sh/',
                    'https://cors.bridged.cc/',
                    'https://crossorigin.me/',
                    'https://thingproxy.freeboard.io/fetch/'
                ]
            };
            
            // Configuração para todas as seções expansíveis
            function setupCollapsibleSection(headerId, containerId, initiallyExpanded = false) {
                const header = document.getElementById(headerId);
                const container = document.getElementById(containerId);
                const toggleBtn = header.querySelector('.toggle-btn');
                
                // Estado inicial
                if (!initiallyExpanded) {
                    container.style.maxHeight = '0px';
                } else {
                    container.style.maxHeight = container.scrollHeight + 'px';
                    toggleBtn.classList.add('active');
                }
                
                header.addEventListener('click', function() {
                    toggleBtn.classList.toggle('active');
                    
                    if (container.style.maxHeight === '0px' || container.style.maxHeight === '') {
                        container.style.maxHeight = container.scrollHeight + 'px';
                    } else {
                        container.style.maxHeight = '0px';
                    }
                });
                
                // Método para atualizar a altura quando o conteúdo muda
                return {
                    updateHeight: function() {
                        if (container.style.maxHeight !== '0px') {
                            container.style.maxHeight = container.scrollHeight + 'px';
                        }
                    }
                };
            }
            
            // Configurar todas as seções expansíveis
            // Alguns são inicialmente expandidos (true), outros não (false)
            const digitCombinationsSection = setupCollapsibleSection('digitCombinationsHeader', 'digitCombinationsContainer', false);
            const configSection = setupCollapsibleSection('configHeader', 'configContainer', true);
            const frequencySection = setupCollapsibleSection('frequencyHeader', 'frequencyContainer', true);
            const combinationsSection = setupCollapsibleSection('combinationsToggleHeader', 'combinationsTableContainer', false);
            const statsSection = setupCollapsibleSection('statsHeader', 'statsContainer', false);
            const specificSection = setupCollapsibleSection('specificHeader', 'specificContainer', false);
            const resultsSection = setupCollapsibleSection('resultsHeader', 'resultsContainer', true);
            
            // Armazenamento de cache local para dados das APIs
            const LOCAL_CACHE = {
                setCached: function(key, data, expiresInMinutes = 60) {
                    try {
                        const item = {
                            data: data,
                            expires: new Date().getTime() + expiresInMinutes * 60 * 1000
                        };
                        localStorage.setItem(key, JSON.stringify(item));
                        return true;
                    } catch (e) {
                        console.error("Erro ao armazenar em cache:", e);
                        return false;
                    }
                },
                
                getCached: function(key, forceRefresh = false) {
                    // Se forceRefresh for true, não usar o cache
                    if (forceRefresh) {
                        return null;
                    }
                    
                    try {
                        const item = JSON.parse(localStorage.getItem(key));
                        if (!item) return null;
                        
                        // Verifica se expirou
                        if (new Date().getTime() > item.expires) {
                            localStorage.removeItem(key);
                            return null;
                        }
                        
                        return item.data;
                    } catch (e) {
                        console.error("Erro ao recuperar cache:", e);
                        return null;
                    }
                },
                
                removeCache: function(key) {
                    try {
                        localStorage.removeItem(key);
                        return true;
                    } catch (e) {
                        console.error("Erro ao remover cache:", e);
                        return false;
                    }
                }
            };

            // Função para gerar TODAS as combinações possíveis de 5 dígitos
            function generateAllDigitCombinations() {
                const digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
                const combinations = [];
                
                // Função auxiliar para gerar combinações de k elementos de um array
                function combinate(arr, k, startIndex, currentCombination, result) {
                    if (currentCombination.length === k) {
                        result.push([...currentCombination]);
                        return;
                    }
                    
                    for (let i = startIndex; i < arr.length; i++) {
                        currentCombination.push(arr[i]);
                        combinate(arr, k, i + 1, currentCombination, result);
                        currentCombination.pop();
                    }
                }
                
                // Gerar combinações de 5 dígitos
                combinate(digits, 5, 0, [], combinations);
                
                // Converter para formato de string (ex: "0,1,2,3,4")
                return combinations.map(combo => combo.join(','));
            }

            // Função para filtrar combinações inválidas para Dia de Sorte
            function filterValidCombinations(allCombinations) {
                // Apenas 126 das 252 combinações são válidas para o Dia de Sorte
                // Esta é apenas uma implementação de exemplo - a lógica real depende das regras específicas
                // Retornamos as mesmas 126 combinações que o usuário forneceu
                
                const validCombinations = [
                    "0,1,2,3,4", "0,1,2,3,5", "0,1,2,3,6", "0,1,2,3,7", "0,1,2,3,8", "0,1,2,3,9", 
                    "0,1,2,4,5", "0,1,2,4,6", "0,1,2,4,7", "0,1,2,4,8", "0,1,2,4,9", "0,1,2,5,6",     
                    "0,1,2,5,7", "0,1,2,5,8", "0,1,2,5,9", "0,1,2,6,7", "0,1,2,6,8", "0,1,2,6,9",     
                    "0,1,2,7,8", "0,1,2,7,9", "0,1,2,8,9", "0,1,3,4,5", "0,1,3,4,6", "0,1,3,4,7",  
                    "0,1,3,4,8", "0,1,3,4,9", "0,1,3,5,6", "0,1,3,5,7", "0,1,3,5,8", "0,1,3,5,9",  
                    "0,1,3,6,7", "0,1,3,6,8", "0,1,3,6,9", "0,1,3,7,8", "0,1,3,7,9", "0,1,3,8,9",     
                    "0,1,4,5,6", "0,1,4,5,7", "0,1,4,5,8", "0,1,4,5,9", "0,1,4,6,7", "0,1,4,6,8",     
                    "0,1,4,6,9", "0,1,4,7,8", "0,1,4,7,9", "0,1,4,8,9", "0,1,5,6,7", "0,1,5,6,8",  
                    "0,1,5,7,9", "0,1,5,8,9", "0,1,6,7,8", "0,1,6,7,9", "0,1,6,8,9", "0,1,7,8,9",  
                    "0,2,3,4,7", "0,2,3,4,8", "0,2,3,4,9", "0,2,3,5,6", "0,2,3,5,7", "0,2,3,5,8",       
                    "0,2,3,6,8", "0,2,3,6,9", "0,2,3,7,8", "0,2,3,7,9", "0,2,3,8,9", "0,2,4,5,6",    
                    "0,2,4,6,8", "0,2,4,6,9", "0,2,4,7,8", "0,2,4,7,9", "0,2,4,8,9", "0,2,5,6,7",      
                    "0,2,5,7,8", "0,2,5,7,9", "0,2,5,8,9", "0,2,6,7,8", "0,2,6,7,9", "0,2,6,8,9",      
                    "1,2,3,4,6", "1,2,3,4,7", "1,2,3,4,8", "1,2,3,4,9", "1,2,3,5,6", "1,2,3,5,7",      
                    "1,2,3,6,8", "1,2,3,6,9", "1,2,3,7,8", "1,2,3,7,9", "1,2,3,8,9", "1,2,4,5,6",      
                    "1,2,4,5,9", "1,2,4,6,7", "1,2,4,6,8", "1,2,4,6,9", "1,2,4,7,8", "1,2,4,7,9",     
                    "1,2,5,6,8", "1,2,5,6,9", "1,2,5,7,8", "1,2,5,7,9", "1,2,5,8,9", "1,2,6,7,8",     
                    "1,2,6,7,9", "1,2,6,8,9", "1,2,7,8,9", "0,2,4,5,7", "0,2,4,5,8", "0,2,4,5,9",     
                    "0,2,4,6,7", "1,2,4,8,9", "1,2,5,6,7", "1,2,4,5,7", "1,2,4,5,8", "0,2,3,5,9",
                    "1,2,3,5,8", "1,2,3,5,9", "1,2,3,6,7", "0,2,7,8,9", "1,2,3,4,5", "0,2,3,6,7", 
                    "0,2,5,6,8", "0,2,5,6,9", "0,1,5,6,9", "0,1,5,7,8", "0,2,3,4,5", "0,2,3,4,6"
                ];
                
                console.log(`Total de combinações geradas: ${allCombinations.length}`);
                console.log(`Total de combinações válidas: ${validCombinations.length}`);
                
                return validCombinations;
            }

            // Gerar todas as combinações possíveis e filtrar as válidas
            const allPossibleCombinations = generateAllDigitCombinations();
            let validDigitCombinations = filterValidCombinations(allPossibleCombinations);
            
            // Fill the textarea with the valid combinations
            document.getElementById('digitCombinations').value = validDigitCombinations.join('\n');

            // Variáveis para armazenar todos os palpites gerados (para download)
            let allGeneratedBets = [];
            let lowBets = [];
            let mediumBets = [];
            let highBets = [];
            let validBetsCount = 0;

            // Variáveis para a funcionalidade de combinação específica
            let specificPossibleNumbers = [];
            let specificGeneratedBets = [];
            let currentPage = 1;
            const itemsPerPage = 12;
            
            // Variáveis para armazenar combinações não sorteadas
            let undrawnCombinations = [];
            
            // Variáveis para armazenar combinações sorteadas e suas frequências
            let drawnCombinations = {};
            
            // Variáveis para estatísticas de categorias de dezenas
            let numberCategoryStats = {
                low: { count: 0, percentage: 0 },
                medium: { count: 0, percentage: 0 },
                high: { count: 0, percentage: 0 },
                total: 0
            };
            
            // Variáveis para estatísticas de dezenas individuais
            let numberFrequency = {};
            
            // Variáveis para estatísticas de meses da sorte
            let monthFrequency = {
                'Jan': 0, 'Fev': 0, 'Mar': 0, 'Abr': 0, 'Mai': 0, 'Jun': 0,
                'Jul': 0, 'Ago': 0, 'Set': 0, 'Out': 0, 'Nov': 0, 'Dez': 0
            };
            
            // Mapeamento de abreviação para nome completo do mês
            const monthNameMap = {
                'Jan': 'Janeiro',
                'Fev': 'Fevereiro',
                'Mar': 'Março',
                'Abr': 'Abril',
                'Mai': 'Maio',
                'Jun': 'Junho',
                'Jul': 'Julho',
                'Ago': 'Agosto',
                'Set': 'Setembro',
                'Out': 'Outubro',
                'Nov': 'Novembro',
                'Dez': 'Dezembro'
            };
            
            // Mapeamento inverso: nome completo para abreviação
            const monthAbbrevMap = {
                'Janeiro': 'Jan',
                'Fevereiro': 'Fev',
                'Março': 'Mar',
                'Abril': 'Abr',
                'Maio': 'Mai',
                'Junho': 'Jun',
                'Julho': 'Jul',
                'Agosto': 'Ago',
                'Setembro': 'Set',
                'Outubro': 'Out',
                'Novembro': 'Nov',
                'Dezembro': 'Dez'
            };
            
            // Inicializar frequência de números
            for (let i = 1; i <= 31; i++) {
                numberFrequency[i] = 0;
            }

            // Preencher o dropdown de combinações específicas
            const specificComboSelect = document.getElementById('specificCombination');
            function updateSpecificComboDropdown() {
                specificComboSelect.innerHTML = '';
                validDigitCombinations.forEach((combo, index) => {
                    const option = document.createElement('option');
                    option.value = combo;
                    
                    // Verificar se a combinação já foi sorteada
                    if (drawnCombinations[combo] && drawnCombinations[combo] > 0) {
                        option.textContent = `${combo} (${drawnCombinations[combo]} ${drawnCombinations[combo] === 1 ? 'vez' : 'vezes'})`;
                    } else {
                        option.textContent = `★ [Não Sorteada] ${combo}`;
                        option.style.fontWeight = 'bold';
                        option.style.color = '#1e40af';  // Cor azul mais escura
                    }
                    
                    specificComboSelect.appendChild(option);
                });
            }
            
            // Chamada inicial
            updateSpecificComboDropdown();

            // Function to generate all possible two-digit numbers from the given digits
            function generateTwoDigitNumbers(digits, maxNumber) {
                const numbers = [];
                for (let i = 0; i < digits.length; i++) {
                    for (let j = 0; j < digits.length; j++) {
                        const num = parseInt(digits[i] + digits[j]);
                        // Add number if it's within range and not already in the list
                        if (num > 0 && num <= maxNumber && !numbers.includes(num)) {
                            numbers.push(num);
                        }
                    }
                }
                return numbers.sort((a, b) => a - b);
            }

            // Function to shuffle array (Fisher-Yates algorithm)
            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }
            
            // Função para gerar um mês da sorte aleatório
            function getRandomMonth() {
                const months = Object.keys(monthAbbrevMap);
                return months[Math.floor(Math.random() * months.length)];
            }
            
            // Função para pegar o mês da sorte mais frequente (ou aleatório se empate)
            function getMostFrequentMonth() {
                // Se não temos dados de frequência, retornar aleatório
                if (Object.values(monthFrequency).every(v => v === 0)) {
                    return getRandomMonth();
                }
                
                // Encontrar o mês mais frequente
                let maxFreq = 0;
                let mostFrequentMonths = [];
                
                for (const [month, freq] of Object.entries(monthFrequency)) {
                    if (freq > maxFreq) {
                        maxFreq = freq;
                        mostFrequentMonths = [month];
                    } else if (freq === maxFreq) {
                        mostFrequentMonths.push(month);
                    }
                }
                
                // Se houver empate, escolher aleatoriamente entre os mais frequentes
                if (mostFrequentMonths.length > 0) {
                    const selectedAbbrev = mostFrequentMonths[Math.floor(Math.random() * mostFrequentMonths.length)];
                    
                    // Encontrar o nome completo a partir da abreviação
                    for (const [name, abbrev] of Object.entries(monthAbbrevMap)) {
                        if (abbrev === selectedAbbrev) {
                            return name;
                        }
                    }
                }
                
                // Fallback para um mês aleatório
                return getRandomMonth();
            }

            // Function to generate a balanced betting sequence with specified distribution
            function generateBalancedBettingSequence(possibleNumbers, numbersPerBet, lowCount, mediumCount, highCount) {
                if (possibleNumbers.length < numbersPerBet) {
                    return null; // Not enough numbers to form a complete bet
                }
                
                // Verify the sum of counts matches the total numbers per bet
                const totalRequested = lowCount + mediumCount + highCount;
                if (totalRequested !== numbersPerBet) {
                    console.warn(`Ajuste nos números solicitados: total ${totalRequested}, necessário ${numbersPerBet}`);
                    // Adjust counts proportionally
                    const factor = numbersPerBet / totalRequested;
                    lowCount = Math.round(lowCount * factor);
                    mediumCount = Math.round(mediumCount * factor);
                    highCount = numbersPerBet - lowCount - mediumCount;
                }
                
                // Categorize available numbers
                const lowNumbers = possibleNumbers.filter(num => num <= 10);
                const mediumNumbers = possibleNumbers.filter(num => num > 10 && num <= 20);
                const highNumbers = possibleNumbers.filter(num => num > 20);
                
                // Check if we have enough numbers in each category
                if (lowNumbers.length < lowCount || mediumNumbers.length < mediumCount || highNumbers.length < highCount) {
                    // Not enough numbers in required distribution, try to adjust
                    let deficit = 0;
                    let adjustedLowCount = Math.min(lowCount, lowNumbers.length);
                    deficit += lowCount - adjustedLowCount;
                    
                    let adjustedMediumCount = Math.min(mediumCount, mediumNumbers.length);
                    deficit += mediumCount - adjustedMediumCount;
                    
                    let adjustedHighCount = Math.min(highCount, highNumbers.length);
                    deficit += highCount - adjustedHighCount;
                    
                    // If we can't meet the deficit, return null
                    if (adjustedLowCount + adjustedMediumCount + adjustedHighCount + deficit > possibleNumbers.length) {
                        console.warn("Não é possível gerar palpite com a distribuição solicitada");
                        return null;
                    }
                    
                    // Distribute deficit among available categories
                    const remainingLow = lowNumbers.length - adjustedLowCount;
                    const remainingMedium = mediumNumbers.length - adjustedMediumCount;
                    const remainingHigh = highNumbers.length - adjustedHighCount;
                    
                    // Distribute deficit proportionally to remaining capacity
                    const totalRemaining = remainingLow + remainingMedium + remainingHigh;
                    if (totalRemaining > 0) {
                        const lowDeficit = Math.min(Math.round((remainingLow / totalRemaining) * deficit), remainingLow);
                        adjustedLowCount += lowDeficit;
                        deficit -= lowDeficit;
                        
                        const mediumDeficit = Math.min(Math.round((remainingMedium / totalRemaining) * deficit), remainingMedium);
                        adjustedMediumCount += mediumDeficit;
                        deficit -= mediumDeficit;
                        
                        // Assign any remaining deficit to high numbers
                        adjustedHighCount += deficit;
                    }
                    
                    lowCount = adjustedLowCount;
                    mediumCount = adjustedMediumCount;
                    highCount = adjustedHighCount;
                }
                
                // Shuffle each category to get random selection
                shuffleArray(lowNumbers);
                shuffleArray(mediumNumbers);
                shuffleArray(highNumbers);
                
                // Select required numbers from each category
                const selectedLow = lowNumbers.slice(0, lowCount);
                const selectedMedium = mediumNumbers.slice(0, mediumCount);
                const selectedHigh = highNumbers.slice(0, highCount);
                
                // Combine and sort for final bet
                return [...selectedLow, ...selectedMedium, ...selectedHigh].sort((a, b) => a - b);
            }

            // Function to format a number with leading zero if needed
            function formatNumber(num) {
                return num < 10 ? '0' + num : num.toString();
            }

            // Function to get number category class
            function getNumberCategoryClass(num) {
                if (num <= 10) return 'number-low';
                if (num <= 20) return 'number-medium';
                return 'number-high';
            }

            // Function to generate and display the results
            function generateResults() {
                // Nota: maxNumber é fixo em 31 agora
                const maxNumber = 31; // parseInt(document.getElementById('maxNumber').value);
                const numbersPerBet = parseInt(document.getElementById('numberPerBet').value);
                const lowRange = parseInt(document.getElementById('lowRange').value);
                const mediumRange = parseInt(document.getElementById('mediumRange').value);
                const highRange = parseInt(document.getElementById('highRange').value);
                
                const resultsContainer = document.getElementById('bettingResults');
                const tableBody = document.getElementById('combinationsTableBody');
                const statisticsContent = document.getElementById('statisticsContent');
                const statisticsTotal = document.getElementById('statisticsTotal');
                
                resultsContainer.innerHTML = '';
                tableBody.innerHTML = '';
                statisticsContent.innerHTML = '';
                
                // Reset the bet arrays and counter
                allGeneratedBets = [];
                lowBets = [];
                mediumBets = [];
                highBets = [];
                validBetsCount = 0;
                
                // Object to count how many combinations generate each number of possibilities
                const stats = {};
                let totalCombinations = 0;
                let lowCount = 0, mediumCount = 0, highCount = 0;
                
                validDigitCombinations.forEach((combination, index) => {
                    const digits = combination.split(',');
                    const possibleNumbers = generateTwoDigitNumbers(digits, maxNumber);
                    const count = possibleNumbers.length;
                    
                    // Update statistics
                    stats[count] = (stats[count] || 0) + 1;
                    totalCombinations++;
                    
                    // Add to combinations table
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td class="px-2 py-2">${combination}</td>
                        <td class="px-2 py-2">${possibleNumbers.map(formatNumber).join(' ')}</td>
                        <td class="px-2 py-2">${count}</td>
                    `;
                    tableBody.appendChild(row);

                    // Create balanced betting sequence
                    const bet = generateBalancedBettingSequence(possibleNumbers, numbersPerBet, lowRange, mediumRange, highRange);
                    
                    if (bet) {
                        validBetsCount++;
                        
                        // Count dezenas por categoria
                        const lowDezenas = bet.filter(num => num <= 10).length;
                        const mediumDezenas = bet.filter(num => num > 10 && num <= 20).length;
                        const highDezenas = bet.filter(num => num > 20).length;
                        
                        // Categorize the bet based on predominant type
                        let category;
                        if (lowDezenas >= mediumDezenas && lowDezenas >= highDezenas) {
                            category = 'low';
                            lowCount++;
                        } else if (mediumDezenas >= lowDezenas && mediumDezenas >= highDezenas) {
                            category = 'medium';
                            mediumCount++;
                        } else {
                            category = 'high';
                            highCount++;
                        }
                        
                        // Gerar um mês da sorte para o palpite
                        // Usar o mês mais frequente ou aleatório se não houver dados
                        const luckyMonth = getMostFrequentMonth();
                        
                        // Store the bet in the appropriate array
                        const betInfo = {
                            index: index + 1,
                            combination: combination,
                            numbers: bet.map(num => formatNumber(num)),
                            category: category,
                            possibleCount: count,
                            luckyMonth: luckyMonth,
                            distribution: {
                                low: lowDezenas,
                                medium: mediumDezenas,
                                high: highDezenas
                            }
                        };
                        
                        allGeneratedBets.push(betInfo);
                        
                        if (category === 'low') lowBets.push(betInfo);
                        else if (category === 'medium') mediumBets.push(betInfo);
                        else if (category === 'high') highBets.push(betInfo);
                        
                        // Set category class
                        let categoryClass = '';
                        let categoryLabel = '';
                        
                        if (category === 'low') {
                            categoryClass = 'border-l-4 border-green-500';
                            categoryLabel = 'Baixas';
                        } else if (category === 'medium') {
                            categoryClass = 'border-l-4 border-yellow-500';
                            categoryLabel = 'Médias';
                        } else if (category === 'high') {
                            categoryClass = 'border-l-4 border-red-500';
                            categoryLabel = 'Altas';
                        }
                        
                        const card = document.createElement('div');
                        card.className = `bg-white dark:bg-gray-800 shadow rounded p-4 ${categoryClass} bet-card` + 
                                       ` ${category}-bet`; // Add class for filtering
                        
                        let numbersHTML = '';
                        bet.forEach(num => {
                            const categoryClass = getNumberCategoryClass(num);
                            numbersHTML += `<span class="inline-block ${categoryClass} rounded-full px-3 py-1 text-sm font-semibold">${formatNumber(num)}</span>`;
                        });
                        
                        // Adicionar o mês da sorte
                        const monthAbbrev = monthAbbrevMap[luckyMonth] || 'Jan';
                        
                        card.innerHTML = `
                            <div class="font-semibold text-primary mb-2 flex justify-between items-center">
                                <span>Palpite #${index + 1}</span>
                                <span class="text-xs bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded-full">
                                    ${numbersPerBet} dezenas + mês
                                </span>
                            </div>
                            <div class="text-xs text-gray-500 dark:text-gray-400 mb-2">Dígitos: ${combination}</div>
                            <div class="flex flex-wrap gap-2 mb-3">
                                ${numbersHTML}
                                <span class="inline-block month-ball ml-1">${monthAbbrev}</span>
                            </div>
                            <div class="flex justify-between items-center">
                                <div class="text-xs text-gray-500 dark:text-gray-400">
                                    <span class="text-green-600 dark:text-green-400">${lowDezenas} baixas</span> | 
                                    <span class="text-yellow-600 dark:text-yellow-400">${mediumDezenas} médias</span> | 
                                    <span class="text-red-600 dark:text-red-400">${highDezenas} altas</span>
                                </div>
                                <span class="px-2 py-1 text-xs rounded-full ${
                                    category === 'low' ? 'bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200' : 
                                    category === 'medium' ? 'bg-yellow-100 dark:bg-yellow-900 text-yellow-800 dark:text-yellow-200' : 
                                    'bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-200'
                                }">${categoryLabel}</span>
                            </div>
                        `;
                        resultsContainer.appendChild(card);
                    } else {
                        const card = document.createElement('div');
                        card.className = 'bg-white dark:bg-gray-800 shadow rounded p-4';
                        card.innerHTML = `
                            <div class="font-semibold text-red-500 mb-2">Palpite #${index + 1} - Dígitos: ${combination}</div>
                            <div class="text-sm text-red-400">Não há números suficientes para formar um palpite equilibrado.</div>
                            <div class="text-xs text-gray-500 dark:text-gray-400">Total de números possíveis: ${count}</div>
                        `;
                        resultsContainer.appendChild(card);
                    }
                });
                
                // Update counters in the UI
                document.getElementById('lowCount').textContent = lowCount;
                document.getElementById('mediumCount').textContent = mediumCount;
                document.getElementById('highCount').textContent = highCount;
                document.getElementById('totalBetsCount').textContent = validBetsCount;
                
                // Generate statistics summary
                const sortedCounts = Object.keys(stats).sort((a, b) => parseInt(a) - parseInt(b));
                
                sortedCounts.forEach(count => {
                    const statItem = document.createElement('div');
                    statItem.className = 'bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded p-3';
                    statItem.innerHTML = `
                        <div class="font-semibold">${stats[count]} conjuntos de dígitos geram ${count} números</div>
                        <div class="text-sm mt-1">${stats[count] === 1 ? 'Representa' : 'Representam'} ${((stats[count] / totalCombinations) * 100).toFixed(1)}% do total</div>
                    `;
                    statisticsContent.appendChild(statItem);
                });
                
                // Add total
                statisticsTotal.innerHTML = `Total: ${totalCombinations} conjuntos de dígitos analisados`;
                
                // Atualizar alturas das seções expansíveis após preencher o conteúdo
                combinationsSection.updateHeight();
                statsSection.updateHeight();
                resultsSection.updateHeight();
                
                // Expandir automaticamente a seção de resultados após gerar
                if (document.getElementById('resultsContainer').style.maxHeight === '0px') {
                    document.getElementById('resultsHeader').click();
                }
            }

            // Função para gerar texto para download
            function generateDownloadText() {
                const maxNumber = 31; // Fixed at 31
                const numbersPerBet = parseInt(document.getElementById('numberPerBet').value);
                const lowRange = parseInt(document.getElementById('lowRange').value);
                const mediumRange = parseInt(document.getElementById('mediumRange').value);
                const highRange = parseInt(document.getElementById('highRange').value);
                
                let text = `PALPITES GERADOS - DIA DE SORTE\n`;
                text += `Números por palpite: ${numbersPerBet} | Número máximo: ${maxNumber}\n`;
                text += `Distribuição pretendida: ${lowRange} baixas, ${mediumRange} médias, ${highRange} altas\n`;
                text += `Data de geração: ${new Date().toLocaleDateString()}\n\n`;
                
                // Adicionar estatísticas
                text += `RESUMO DOS PALPITES:\n`;
                text += `Total de palpites gerados: ${validBetsCount}\n`;
                text += `Palpites com predominância de dezenas baixas (1-10): ${document.getElementById('lowCount').textContent}\n`;
                text += `Palpites com predominância de dezenas médias (11-20): ${document.getElementById('mediumCount').textContent}\n`;
                text += `Palpites com predominância de dezenas altas (21-31): ${document.getElementById('highCount').textContent}\n\n`;
                
                // Adicionar palpites por categoria
                text += `=== PALPITES COM PREDOMINÂNCIA DE DEZENAS BAIXAS (1-10) ===\n\n`;
                lowBets.forEach(bet => {
                    text += `Palpite #${bet.index} - Dígitos: ${bet.combination}\n`;
                    text += `Números: ${bet.numbers.join(' ')} ${monthAbbrevMap[bet.luckyMonth]}\n`;
                    text += `Distribuição: ${bet.distribution.low} baixas, ${bet.distribution.medium} médias, ${bet.distribution.high} altas\n\n`;
                });
                
                text += `=== PALPITES COM PREDOMINÂNCIA DE DEZENAS MÉDIAS (11-20) ===\n\n`;
                mediumBets.forEach(bet => {
                    text += `Palpite #${bet.index} - Dígitos: ${bet.combination}\n`;
                    text += `Números: ${bet.numbers.join(' ')} ${monthAbbrevMap[bet.luckyMonth]}\n`;
                    text += `Distribuição: ${bet.distribution.low} baixas, ${bet.distribution.medium} médias, ${bet.distribution.high} altas\n\n`;
                });
                
                text += `=== PALPITES COM PREDOMINÂNCIA DE DEZENAS ALTAS (21-31) ===\n\n`;
                highBets.forEach(bet => {
                    text += `Palpite #${bet.index} - Dígitos: ${bet.combination}\n`;
                    text += `Números: ${bet.numbers.join(' ')} ${monthAbbrevMap[bet.luckyMonth]}\n`;
                    text += `Distribuição: ${bet.distribution.low} baixas, ${bet.distribution.medium} médias, ${bet.distribution.high} altas\n\n`;
                });
                
                return text;
            }

            // Função para gerar texto simples para download (apenas os números)
            function generateSimpleDownloadText() {
                let text = '';
                
                // Apenas os números de cada palpite, separados por espaço
                allGeneratedBets.forEach(bet => {
                    text += `${bet.numbers.join(' ')} ${monthAbbrevMap[bet.luckyMonth]}\n`;
                });
                
                return text;
            }
            
            // Função para gerar texto de download das combinações não sorteadas
            function generateUndrawnCombinationsText() {
                let text = `COMBINAÇÕES AINDA NÃO SORTEADAS - DIA DE SORTE\n`;
                text += `Data de extração: ${new Date().toLocaleDateString()}\n\n`;
                text += `Total de combinações não sorteadas: ${undrawnCombinations.length} de ${validDigitCombinations.length}\n\n`;
                
                text += undrawnCombinations.join('\n');
                
                return text;
            }
            
            // Função para download de combinações não sorteadas
            function downloadUndrawnCombinations() {
                if (undrawnCombinations.length === 0) {
                    alert('Não há combinações não sorteadas para baixar ou a análise ainda não foi realizada.');
                    return;
                }
                
                const textContent = generateUndrawnCombinationsText();
                const blob = new Blob([textContent], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                
                // Criar um link temporário e simular clique
                const a = document.createElement('a');
                a.href = url;
                a.download = 'combinacoes_nao_sorteadas.txt';
                document.body.appendChild(a);
                a.click();
                
                // Limpar
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
            }

            // Função para download dos palpites detalhados
            function downloadBets() {
                if (allGeneratedBets.length === 0) {
                    alert('Gere os palpites primeiro antes de baixar.');
                    return;
                }
                
                const textContent = generateDownloadText();
                const blob = new Blob([textContent], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                
                // Criar um link temporário e simular clique
                const a = document.createElement('a');
                a.href = url;
                a.download = 'palpites_dia_de_sorte.txt';
                document.body.appendChild(a);
                a.click();
                
                // Limpar
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
            }

            // Função para download dos palpites simplificados (apenas os números)
            function downloadSimpleBets() {
                if (allGeneratedBets.length === 0) {
                    alert('Gere os palpites primeiro antes de baixar.');
                    return;
                }
                
                const textContent = generateSimpleDownloadText();
                const blob = new Blob([textContent], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                
                // Criar um link temporário e simular clique
                const a = document.createElement('a');
                a.href = url;
                a.download = 'palpites_simples.txt';
                document.body.appendChild(a);
                a.click();
                
                // Limpar
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
            }

            // Função para configurar paginação dos resultados específicos
            function setupPagination() {
                const totalPages = Math.ceil(specificGeneratedBets.length / itemsPerPage);
                const paginationInfo = document.getElementById('paginationInfo');
                const prevBtn = document.getElementById('prevPageBtn');
                const nextBtn = document.getElementById('nextPageBtn');
                
                // Atualizar informações de página
                paginationInfo.textContent = `Página ${currentPage} de ${totalPages || 1}`;
                
                // Habilitar/desabilitar botões
                prevBtn.disabled = currentPage <= 1;
                nextBtn.disabled = currentPage >= totalPages;
                
                // Mostrar resultados da página atual
                showSpecificBetsPage();
                
                // Atualizar altura da seção expansível
                specificSection.updateHeight();
            }

            // Função para mostrar a página atual de palpites específicos
            function showSpecificBetsPage() {
                const startIndex = (currentPage - 1) * itemsPerPage;
                const endIndex = Math.min(startIndex + itemsPerPage, specificGeneratedBets.length);
                const resultsContainer = document.getElementById('specificResultsContainer');
                
                resultsContainer.innerHTML = '';
                
                // Se não há resultados
                if (specificGeneratedBets.length === 0) {
                    resultsContainer.innerHTML = `
                        <div class="col-span-full p-4 text-center text-gray-500 dark:text-gray-400">
                            Nenhum palpite gerado. Selecione uma combinação e clique em "Gerar Palpites".
                        </div>
                    `;
                    return;
                }
                
                // Mostrar palpites da página atual
                for (let i = startIndex; i < endIndex; i++) {
                    const bet = specificGeneratedBets[i];
                    const card = document.createElement('div');
                    card.className = 'bg-white dark:bg-gray-800 shadow rounded p-4';
                    
                    let numbersHTML = '';
                    bet.numbers.forEach(num => {
                        const parsedNum = parseInt(num);
                        const categoryClass = getNumberCategoryClass(parsedNum);
                        numbersHTML += `<span class="inline-block ${categoryClass} rounded-full px-3 py-1 text-sm font-semibold">${num}</span>`;
                    });
                    
                    // Adicionar o mês da sorte
                    const monthAbbrev = monthAbbrevMap[bet.luckyMonth] || 'Jan';
                    
                    const lowCount = bet.numbers.filter(n => parseInt(n) <= 10).length;
                    const mediumCount = bet.numbers.filter(n => parseInt(n) > 10 && parseInt(n) <= 20).length;
                    const highCount = bet.numbers.filter(n => parseInt(n) > 20).length;
                    
                    card.innerHTML = `
                        <div class="font-semibold text-primary mb-2 flex justify-between">
                            <span>Palpite #${i + 1}</span>
                            <span class="text-xs bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded-full">
                                ${bet.numbers.length} dezenas + mês
                            </span>
                        </div>
                        <div class="flex flex-wrap gap-2 mb-3">
                            ${numbersHTML}
                            <span class="inline-block month-ball ml-1">${monthAbbrev}</span>
                        </div>
                        <div class="text-xs text-gray-500 dark:text-gray-400">
                            <span class="text-green-600 dark:text-green-400">${lowCount} baixas</span> | 
                            <span class="text-yellow-600 dark:text-yellow-400">${mediumCount} médias</span> | 
                            <span class="text-red-600 dark:text-red-400">${highCount} altas</span>
                        </div>
                    `;
                    resultsContainer.appendChild(card);
                }
            }

            // Função para gerar todas as combinações possíveis de K elementos em um array
            function generateCombinations(array, k) {
                const result = [];
                
                // Função recursiva para gerar combinações
                function backtrack(start, current) {
                    if (current.length === k) {
                        result.push([...current]);
                        return;
                    }
                    
                    for (let i = start; i < array.length; i++) {
                        current.push(array[i]);
                        backtrack(i + 1, current);
                        current.pop();
                    }
                }
                
                backtrack(0, []);
                return result;
            }

            // Função para mostrar os números possíveis para a combinação selecionada
            function updatePossibleNumbers() {
                const selectedCombo = document.getElementById('specificCombination').value;
                const maxNumber = 31; // Fixo em 31
                const digits = selectedCombo.split(',');
                
                specificPossibleNumbers = generateTwoDigitNumbers(digits, maxNumber);
                
                // Atualizar a contagem de dezenas possíveis
                const countElement = document.getElementById('possibleNumberCount');
                countElement.textContent = specificPossibleNumbers.length;
                
                // Atualizar a exibição dos números possíveis
                const display = document.getElementById('possibleNumbersDisplay');
                display.innerHTML = '';
                
                specificPossibleNumbers.forEach(num => {
                    const numStr = formatNumber(num);
                    const categoryClass = getNumberCategoryClass(num);
                    const span = document.createElement('span');
                    span.className = `inline-block ${categoryClass} rounded-full px-3 py-1 text-sm font-semibold`;
                    span.textContent = numStr;
                    display.appendChild(span);
                });
                
                // Limpar resultados anteriores
                specificGeneratedBets = [];
                document.getElementById('specificBetCount').textContent = '0';
                document.getElementById('specificResultsContainer').innerHTML = '';
                document.getElementById('downloadSpecificBtn').disabled = true;
                document.getElementById('downloadSpecificSimpleBtn').disabled = true;
                
                // Atualizar altura da seção expansível
                specificSection.updateHeight();
                
                setupPagination();
            }

            // Função para gerar palpites para a combinação específica
            function generateSpecificBets() {
                const numbersPerBet = parseInt(document.getElementById('specificNumberPerBet').value);
                const selectedCombo = document.getElementById('specificCombination').value;
                const lowRange = parseInt(document.getElementById('lowRange').value);
                const mediumRange = parseInt(document.getElementById('mediumRange').value);
                const highRange = parseInt(document.getElementById('highRange').value);
                
                // Verificar se há números suficientes
                if (specificPossibleNumbers.length < numbersPerBet) {
                    alert(`Esta combinação gera apenas ${specificPossibleNumbers.length} números possíveis, o que é insuficiente para formar um palpite com ${numbersPerBet} dezenas.`);
                    return;
                }
                
                // Calcular todas as combinações possíveis
                const allCombos = generateCombinations(specificPossibleNumbers, numbersPerBet);
                
                // Gerar palpites balanceados, considerando a distribuição
                specificGeneratedBets = [];
                
                allCombos.forEach(combo => {
                    // Classificar os números por categoria
                    const lowCount = combo.filter(num => num <= 10).length;
                    const mediumCount = combo.filter(num => num > 10 && num <= 20).length;
                    const highCount = combo.filter(num => num > 20).length;
                    
                    // Verificar se a distribuição está próxima da desejada
                    // Adicionamos uma tolerância para permitir variações
                    const isBalanced = Math.abs(lowCount - lowRange) <= 2 && 
                                       Math.abs(mediumCount - mediumRange) <= 2 && 
                                       Math.abs(highCount - highRange) <= 2;
                    
                    specificGeneratedBets.push({
                        numbers: combo.map(num => formatNumber(num)),
                        luckyMonth: getMostFrequentMonth(), // Adicionar mês da sorte
                        isBalanced: isBalanced
                    });
                });
                
                // Ordenar para que os palpites balanceados apareçam primeiro
                specificGeneratedBets.sort((a, b) => {
                    if (a.isBalanced && !b.isBalanced) return -1;
                    if (!a.isBalanced && b.isBalanced) return 1;
                    return 0;
                });
                
                // Atualizar contador e habilitar botões de download
                document.getElementById('specificBetCount').textContent = specificGeneratedBets.length;
                document.getElementById('downloadSpecificBtn').disabled = false;
                document.getElementById('downloadSpecificSimpleBtn').disabled = false;
                
                // Configurar paginação e mostrar resultados
                currentPage = 1;
                setupPagination();
                
                // Expandir a seção se estiver fechada
                if (document.getElementById('specificContainer').style.maxHeight === '0px') {
                    document.getElementById('specificHeader').click();
                }
            }

            // Função para gerar texto de download dos palpites específicos
            function generateSpecificDownloadText() {
                if (specificGeneratedBets.length === 0) return '';
                
                const selectedCombo = document.getElementById('specificCombination').value;
                const numbersPerBet = parseInt(document.getElementById('specificNumberPerBet').value);
                
                let text = `PALPITES GERADOS PARA COMBINAÇÃO DE DÍGITOS: ${selectedCombo}\n`;
                text += `Números por palpite: ${numbersPerBet}\n`;
                text += `Data de geração: ${new Date().toLocaleDateString()}\n\n`;
                text += `Total de palpites: ${specificGeneratedBets.length}\n\n`;
                
                // Adicionar cada palpite
                specificGeneratedBets.forEach((bet, index) => {
                    text += `Palpite #${index + 1}: ${bet.numbers.join(' ')} ${monthAbbrevMap[bet.luckyMonth]}\n`;
                });
                
                return text;
            }
            
            // Função para gerar texto simples de download dos palpites específicos
            function generateSpecificSimpleDownloadText() {
                if (specificGeneratedBets.length === 0) return '';
                
                let text = '';
                
                // Adicionar cada palpite, apenas números e mês
                specificGeneratedBets.forEach(bet => {
                    text += `${bet.numbers.join(' ')} ${monthAbbrevMap[bet.luckyMonth]}\n`;
                });
                
                return text;
            }

            // Função para download dos palpites específicos detalhados
            function downloadSpecificBets() {
                if (specificGeneratedBets.length === 0) {
                    alert('Nenhum palpite foi gerado para download.');
                    return;
                }
                
                const textContent = generateSpecificDownloadText();
                const blob = new Blob([textContent], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                
                // Criar um link temporário e simular clique
                const a = document.createElement('a');
                a.href = url;
                a.download = 'palpites_específicos.txt';
                document.body.appendChild(a);
                a.click();
                
                // Limpar
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
            }
            
            // Função para download dos palpites específicos simplificados
            function downloadSpecificSimpleBets() {
                if (specificGeneratedBets.length === 0) {
                    alert('Nenhum palpite foi gerado para download.');
                    return;
                }
                
                const textContent = generateSpecificSimpleDownloadText();
                const blob = new Blob([textContent], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                
                // Criar um link temporário e simular clique
                const a = document.createElement('a');
                a.href = url;
                a.download = 'palpites_específicos_simples.txt';
                document.body.appendChild(a);
                a.click();
                
                // Limpar
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
            }

            // Configurar abas para filtrar os palpites
            function setupTabs() {
                const allTab = document.getElementById('allBetsTab');
                const lowTab = document.getElementById('lowBetsTab');
                const mediumTab = document.getElementById('mediumBetsTab');
                const highTab = document.getElementById('highBetsTab');
                
                // Função para atualizar a aparência das abas
                function updateTabAppearance(activeTab) {
                    // Remover estilos ativos de todas as abas
                    [allTab, lowTab, mediumTab, highTab].forEach(tab => {
                        tab.classList.remove('border-b-2', 'border-primary', 'text-primary');
                        tab.classList.add('text-gray-600', 'dark:text-gray-400');
                    });
                    
                    // Adicionar estilos à aba ativa
                    activeTab.classList.remove('text-gray-600', 'dark:text-gray-400');
                    activeTab.classList.add('border-b-2', 'border-primary', 'text-primary');
                }
                
                // Configurar manipuladores de eventos
                allTab.addEventListener('click', function() {
                    document.querySelectorAll('.bet-card').forEach(card => {
                        card.style.display = 'block';
                    });
                    updateTabAppearance(allTab);
                });
                
                lowTab.addEventListener('click', function() {
                    document.querySelectorAll('.bet-card').forEach(card => {
                        if (card.classList.contains('low-bet')) {
                            card.style.display = 'block';
                        } else {
                            card.style.display = 'none';
                        }
                    });
                    updateTabAppearance(lowTab);
                });
                
                mediumTab.addEventListener('click', function() {
                    document.querySelectorAll('.bet-card').forEach(card => {
                        if (card.classList.contains('medium-bet')) {
                            card.style.display = 'block';
                        } else {
                            card.style.display = 'none';
                        }
                    });
                    updateTabAppearance(mediumTab);
                });
                
                highTab.addEventListener('click', function() {
                    document.querySelectorAll('.bet-card').forEach(card => {
                        if (card.classList.contains('high-bet')) {
                            card.style.display = 'block';
                        } else {
                            card.style.display = 'none';
                        }
                    });
                    updateTabAppearance(highTab);
                });
            }
            
            // Função para renderizar o gráfico de barras da estatística de dezenas
            function renderNumberCategoryChart() {
                // Calcula as percentagens para o gráfico
                const total = numberCategoryStats.total;
                if (total === 0) return;
                
                // Atualizar percentagens
                numberCategoryStats.low.percentage = (numberCategoryStats.low.count / total) * 100;
                numberCategoryStats.medium.percentage = (numberCategoryStats.medium.count / total) * 100;
                numberCategoryStats.high.percentage = (numberCategoryStats.high.count / total) * 100;
                
                // Renderizar as barras diretamente
                const lowBar = document.getElementById('lowBar');
                const mediumBar = document.getElementById('mediumBar');
                const highBar = document.getElementById('highBar');
                
                if (lowBar && mediumBar && highBar) {
                    // Definir as alturas e textos das barras
                    lowBar.style.height = `${Math.max(10, numberCategoryStats.low.percentage)}%`;
                    lowBar.textContent = `${Math.round(numberCategoryStats.low.percentage)}%`;
                    
                    mediumBar.style.height = `${Math.max(10, numberCategoryStats.medium.percentage)}%`;
                    mediumBar.textContent = `${Math.round(numberCategoryStats.medium.percentage)}%`;
                    
                    highBar.style.height = `${Math.max(10, numberCategoryStats.high.percentage)}%`;
                    highBar.textContent = `${Math.round(numberCategoryStats.high.percentage)}%`;
                    
                    // Atualizar rótulos abaixo das barras
                    lowBar.nextElementSibling.innerHTML = `${numberCategoryStats.low.count} dezenas<br>baixas`;
                    mediumBar.nextElementSibling.innerHTML = `${numberCategoryStats.medium.count} dezenas<br>Médias`;
                    highBar.nextElementSibling.innerHTML = `${numberCategoryStats.high.count} dezenas<br>Altas`;
                }
                
                // Atualiza os detalhes numéricos
                document.getElementById('lowNumberStats').innerHTML = `
                    <div><strong>${numberCategoryStats.low.count}</strong> dezenas (${numberCategoryStats.low.percentage.toFixed(1)}%)</div>
                    <div class="text-sm italic">1, 2, 3, 4, 5, 6, 7, 8, 9, 10</div>
                `;
                document.getElementById('mediumNumberStats').innerHTML = `
                    <div><strong>${numberCategoryStats.medium.count}</strong> dezenas (${numberCategoryStats.medium.percentage.toFixed(1)}%)</div>
                    <div class="text-sm italic">11, 12, 13, 14, 15, 16, 17, 18, 19, 20</div>
                `;
                document.getElementById('highNumberStats').innerHTML = `
                    <div><strong>${numberCategoryStats.high.count}</strong> dezenas (${numberCategoryStats.high.percentage.toFixed(1)}%)</div>
                    <div class="text-sm italic">21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31</div>
                `;
                
                // Exibir seção de estatísticas
                document.getElementById('numberCategoryStats').style.display = 'block';
            }
            
            // Função para renderizar as estatísticas de frequência de cada número
            function renderNumberFrequencyGrid() {
                const grid = document.getElementById('numberFrequencyGrid');
                
                if (!grid) return;
                
                grid.innerHTML = '';
                
                // Encontrar valor máximo para destacar os mais frequentes
                const maxFreq = Math.max(...Object.values(numberFrequency));
                
                // Gerar uma classe baseada na frequência relativa
                function getFrequencyClass(freq) {
                    if (maxFreq === 0) return 'freq-low';
                    
                    const relativeFreq = freq / maxFreq;
                    if (relativeFreq > 0.7) return 'freq-high';
                    if (relativeFreq > 0.4) return 'freq-medium';
                    return 'freq-low';
                }
                
                // Criar elemento para cada número
                for (let i = 1; i <= 31; i++) {
                    const freq = numberFrequency[i] || 0;
                    const freqClass = getFrequencyClass(freq);
                    
                    const ball = document.createElement('div');
                    ball.className = `frequency-ball ${freqClass}`;
                    
                    // Mostrar número
                    ball.innerHTML = formatNumber(i);
                    
                    // Adicionar contador de frequência se > 0
                    if (freq > 0) {
                        const freqValue = document.createElement('div');
                        freqValue.className = 'freq-value';
                        freqValue.textContent = freq;
                        ball.appendChild(freqValue);
                    }
                    
                    grid.appendChild(ball);
                }
            }
            
            // Função para renderizar as estatísticas de frequência dos meses
            function renderMonthFrequency() {
                const totalResults = Object.values(monthFrequency).reduce((sum, freq) => sum + freq, 0);
                
                if (totalResults === 0) return; // Não temos dados de mês
                
                // Encontrar os meses mais frequentes
                const maxFreq = Math.max(...Object.values(monthFrequency));
                
                // Atualizar cada elemento de mês
                for (const [abbrev, fullName] of Object.entries(monthNameMap)) {
                    const freq = monthFrequency[abbrev] || 0;
                    const percentage = totalResults > 0 ? (freq / totalResults * 100).toFixed(1) : '0.0';
                    
                    // ID do elemento do mês (Jan -> monthJan)
                    const monthEl = document.getElementById(`month${abbrev}`);
                    if (monthEl) {
                        // Atualizar o valor e porcentagem
                        const valueEl = monthEl.querySelector('.text-2xl');
                        const percentEl = monthEl.querySelector('.text-sm');
                        
                        if (valueEl) valueEl.textContent = freq;
                        if (percentEl) percentEl.textContent = `${percentage}%`;
                        
                        // Destacar o mês mais frequente
                        if (freq === maxFreq && freq > 0) {
                            monthEl.classList.add('month-highlight');
                        } else {
                            monthEl.classList.remove('month-highlight');
                        }
                    }
                }
            }

            // Function to extract digits from a number
            function getDigits(num) {
                return num.toString().padStart(2, '0').split('').map(Number);
            }

            // Function to parse a month name or abbreviation 
            function parseMonth(monthStr) {
                if (!monthStr) return null;
                
                // Normalize the month string (trim, uppercase first letter)
                const normalizedMonth = monthStr.trim();
                
                // Try to match directly with our abbreviations
                for (const abbrev of Object.keys(monthNameMap)) {
                    // Match exact abbreviation
                    if (normalizedMonth.toLowerCase() === abbrev.toLowerCase()) {
                        return abbrev;
                    }
                    
                    // Match beginning of month name
                    const fullName = monthNameMap[abbrev];
                    if (normalizedMonth.toLowerCase() === fullName.toLowerCase() ||
                        normalizedMonth.toLowerCase().startsWith(fullName.toLowerCase().substring(0, 3)) || 
                        fullName.toLowerCase().startsWith(normalizedMonth.toLowerCase())) {
                        return abbrev;
                    }
                }
                
                // No match found
                return null;
            }

            // Function to analyze the frequency of digit combinations in historical results
            function analyzeFrequency() {
                const resultsText = document.getElementById('historicalResults').value.trim();
                if (!resultsText) {
                    alert('Por favor, insira os resultados históricos.');
                    return;
                }

                const results = [];
                const lines = resultsText.split('\n');
                
                // Reset statistics
                numberCategoryStats = {
                    low: { count: 0, percentage: 0 },
                    medium: { count: 0, percentage: 0 },
                    high: { count: 0, percentage: 0 },
                    total: 0
                };
                
                // Reset number frequency
                for (let i = 1; i <= 31; i++) {
                    numberFrequency[i] = 0;
                }
                
                // Reset month frequency
                for (const month in monthFrequency) {
                    monthFrequency[month] = 0;
                }

                // Parse each line of results
                for (const line of lines) {
                    if (line.trim() === '') continue;
                    
                    // Split the line into words
                    const parts = line.trim().split(/\s+/);
                    
                    // Check if the last part might be a month
                    let numbers = [];
                    let month = null;
                    
                    // If we have at least 7 numbers
                    if (parts.length >= 7) {
                        // Try to parse the last item as a month
                        if (parts.length > 7) {
                            const lastPart = parts[parts.length - 1];
                            month = parseMonth(lastPart);
                            
                            if (month) {
                                // If it's a month, exclude it from numbers
                                numbers = parts.slice(0, -1).map(n => parseInt(n.trim()));
                            } else {
                                // No month found, all parts are numbers
                                numbers = parts.map(n => parseInt(n.trim()));
                            }
                        } else {
                            // Exactly 7 parts, assume all are numbers
                            numbers = parts.map(n => parseInt(n.trim()));
                        }
                        
                        // Increment month frequency if a month was found
                        if (month) {
                            monthFrequency[month]++;
                        }
                        
                        results.push({
                            numbers: numbers,
                            month: month
                        });
                        
                        // Count numbers by category for statistics
                        numbers.forEach(num => {
                            if (num >= 1 && num <= 31) { // Ensure valid numbers only
                                numberCategoryStats.total++;
                                
                                // Increment the frequency for this specific number
                                numberFrequency[num] = (numberFrequency[num] || 0) + 1;
                                
                                if (num <= 10) {
                                    numberCategoryStats.low.count++;
                                } else if (num <= 20) {
                                    numberCategoryStats.medium.count++;
                                } else {
                                    numberCategoryStats.high.count++;
                                }
                            }
                        });
                    }
                }

                if (results.length === 0) {
                    alert('Nenhum resultado válido encontrado. Verifique o formato.');
                    return;
                }
                
                // Renderiza o gráfico de estatísticas de categorias
                renderNumberCategoryChart();
                
                // Renderiza a grade de frequência dos números
                renderNumberFrequencyGrid();
                
                // Renderiza a frequência dos meses
                renderMonthFrequency();

                // Count digit occurrences in each result
                const digitCombinationCounts = {};
                
                // Inicializar contadores para todas as combinações possíveis
                validDigitCombinations.forEach(combo => {
                    digitCombinationCounts[combo] = 0;
                });
                
                // Iterate through each result
                results.forEach(result => {
                    // Get all digits from all numbers in this result
                    const allDigits = new Set();
                    result.numbers.forEach(num => {
                        getDigits(num).forEach(digit => allDigits.add(digit));
                    });
                    
                    // Convert to array and sort
                    const digitsArray = Array.from(allDigits).sort((a, b) => a - b);
                    
                    // Only consider results with 5 or more distinct digits
                    if (digitsArray.length >= 5) {
                        // Verificar quais das combinações válidas estão presentes neste resultado
                        validDigitCombinations.forEach(combo => {
                            const comboDigits = combo.split(',').map(Number);
                            
                            // Verificar se todos os dígitos da combinação estão presentes
                            if (comboDigits.every(digit => digitsArray.includes(digit))) {
                                digitCombinationCounts[combo]++;
                            }
                        });
                    }
                });

                // Guardar as frequências para uso posterior
                drawnCombinations = {...digitCombinationCounts};
                
                // Convert to array for sorting
                const combinationsArray = Object.entries(digitCombinationCounts)
                    .map(([combo, count]) => ({ combo, count }))
                    .sort((a, b) => b.count - a.count);

                // Identificar combinações que ainda não foram sorteadas
                undrawnCombinations = validDigitCombinations.filter(combo => 
                    digitCombinationCounts[combo] === 0
                );
                
                // Atualizar contador de combinações não sorteadas
                document.getElementById('undrawnCountDisplay').textContent = undrawnCombinations.length;
                
                // Display results
                const frequencyResults = document.getElementById('frequencyResults');
                const frequencyTableBody = document.getElementById('frequencyTableBody');
                const topCombinations = document.getElementById('topCombinations');
                const undrawnCombinationsContent = document.getElementById('undrawnCombinationsContent');

                frequencyResults.classList.remove('hidden');
                frequencyTableBody.innerHTML = '';
                undrawnCombinationsContent.innerHTML = '';
                
                if (combinationsArray.length === 0) {
                    topCombinations.innerHTML = 'Nenhuma combinação de 5 dígitos encontrada nos resultados.';
                    return;
                }

                // Show the top combinations with highlighting for 5 digits
                const top5Combos = combinationsArray.filter(item => item.count > 0).slice(0, 5);
                
                let topCombosHTML = `
                    <div class="font-bold text-xl mb-3 flex items-center">
                        Combinações de <span class="mx-1 bg-green-200 dark:bg-green-700 text-green-800 dark:text-green-200 px-2 py-0.5 rounded-full">5</span> Dígitos Mais Frequentes
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                `;
                
                top5Combos.forEach((item, index) => {
                    const percentage = ((item.count / results.length) * 100).toFixed(1);
                    topCombosHTML += `
                        <div class="bg-green-100 dark:bg-green-900 p-3 rounded-lg border-2 border-green-500">
                            <div class="font-bold text-lg text-green-800 dark:text-green-200">${index + 1}. ${item.combo}</div>
                            <div class="text-green-700 dark:text-green-300">
                                ${item.count} de ${results.length} resultados (${percentage}%)
                            </div>
                        </div>
                    `;
                });
                
                topCombosHTML += `</div>`;
                
                // Adicionar informação sobre combinações que ainda não apareceram
                topCombosHTML += `
                    <div class="mt-4 p-3 bg-yellow-100 dark:bg-yellow-900 rounded-lg">
                        <div class="font-bold text-yellow-800 dark:text-yellow-200">
                            ${undrawnCombinations.length} combinações ainda não apareceram em nenhum sorteio (de um total de ${validDigitCombinations.length})
                        </div>
                    </div>
                `;
                
                topCombinations.innerHTML = topCombosHTML;
                
                // Mostrar as combinações não sorteadas
                if (undrawnCombinations.length > 0) {
                    undrawnCombinations.forEach(combo => {
                        const comboDiv = document.createElement('div');
                        comboDiv.className = 'bg-blue-50 dark:bg-blue-800 p-2 rounded border border-blue-200 dark:border-blue-700';
                        comboDiv.innerHTML = `<div class="text-blue-800 dark:text-blue-200 font-medium">${combo}</div>`;
                        undrawnCombinationsContent.appendChild(comboDiv);
                    });
                    
                    document.getElementById('undrawnCombinations').style.display = 'block';
                    
                    // NOVA FUNCIONALIDADE: Preencher a área "Combinações de Dígitos" com apenas as não sorteadas
                    document.getElementById('digitCombinations').value = undrawnCombinations.join('\n');
                    
                    // Atualizar a variável global para usar apenas as combinações não sorteadas
                    validDigitCombinations = [...undrawnCombinations];
                    
                    // Atualizar o texto do cabeçalho
                    const combinationsHeader = document.querySelector('#digitCombinationsHeader h2');
                    if (combinationsHeader) {
                        combinationsHeader.innerHTML = `
                            <span>Combinações de Dígitos</span> 
                            <span class="text-sm font-bold ml-2 bg-blue-100 dark:bg-blue-800 text-blue-800 dark:text-blue-200 px-2 py-0.5 rounded-full">(${undrawnCombinations.length})</span>
                        `;
                    }
                    
                    // Limpar quaisquer palpites gerados anteriormente
                    document.getElementById('bettingResults').innerHTML = '';
                    document.getElementById('totalBetsCount').textContent = '0';
                    document.getElementById('lowCount').textContent = '0';
                    document.getElementById('mediumCount').textContent = '0';
                    document.getElementById('highCount').textContent = '0';
                    
                    // Expandir a seção de combinações de dígitos
                    if (document.getElementById('digitCombinationsContainer').style.maxHeight === '0px') {
                        document.getElementById('digitCombinationsHeader').click();
                    }
                } else {
                    document.getElementById('undrawnCombinations').style.display = 'none';
                }

                // Fill the frequency table with all combinations that appeared
                combinationsArray.filter(item => item.count > 0).forEach(({ combo, count }) => {
                    const percentage = ((count / results.length) * 100).toFixed(1);
                    
                    const row = document.createElement('tr');
                    
                    // Destacar as combinações de 5 dígitos
                    row.classList.add('bg-green-100', 'dark:bg-green-800');
                    row.innerHTML = `
                        <td class="px-2 py-2 font-bold">${combo}</td>
                        <td class="px-2 py-2 font-bold">${count} de ${results.length}</td>
                        <td class="px-2 py-2 font-bold">${percentage}%</td>
                    `;
                    
                    frequencyTableBody.appendChild(row);
                });
                
                // Atualizar altura da seção de frequência após preenchimento
                frequencySection.updateHeight();
                
                // Atualizar o dropdown para mostrar as frequências nas combinações
                updateSpecificComboDropdown();
                
                // Disparar evento change para atualizar a exibição
                specificComboSelect.dispatchEvent(new Event('change'));
            }
            
            // Função para buscar todos os resultados históricos com opção de forçar atualização
            async function fetchAllHistoricalResults() {
                // Verificar se o usuário quer forçar a atualização
                const forceRefresh = document.getElementById('forceRefresh').checked;
                
                // Mostrar spinner de carregamento
                const spinner = document.getElementById('loadingAllSpinner');
                spinner.classList.remove('hidden');
                
                const apiStatus = document.getElementById('apiStatus');
                const apiStatusContent = document.getElementById('apiStatusContent');
                
                apiStatus.classList.remove('hidden');
                apiStatusContent.innerHTML = `Buscando todos os resultados históricos ${forceRefresh ? "(atualizando cache)" : ""}...`;
                
                try {
                    // Verificar cache primeiro - só usar se não forçar atualização
                    const cacheKey = 'dia_de_sorte_all_history';
                    if (!forceRefresh) {
                        const cachedData = LOCAL_CACHE.getCached(cacheKey);
                        
                        if (cachedData) {
                            apiStatusContent.innerHTML += '<br>✅ Dados encontrados no cache local.';
                            document.getElementById('historicalResults').value = cachedData;
                            analyzeFrequency(); // Analisar os dados obtidos
                            spinner.classList.add('hidden');
                            return;
                        }
                    } else {
                        // Se forçar atualização, remover o cache existente
                        LOCAL_CACHE.removeCache(cacheKey);
                        apiStatusContent.innerHTML += '<br>🔄 Cache limpo. Buscando dados atualizados...';
                    }
                    
                    // Tentar a API Heroku primeiro (geralmente a mais confiável)
                    apiStatusContent.innerHTML += '<br>Tentando buscar dados completos da API Heroku...';
                    
                    try {
                        const response = await fetch(API_CONFIG.HEROKU_URL, {
                            method: 'GET',
                            headers: { 
                                'Accept': 'application/json',
                                'Cache-Control': 'no-cache, no-store, must-revalidate'
                            },
                            cache: 'no-store' // Força o navegador a ignorar o cache
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            if (data && Array.isArray(data) && data.length > 0) {
                                // Processar os resultados
                                const formattedResults = data.map(contest => {
                                    let mesSorte = '';
                                    if (contest.mesDaSorte) {
                                        // Tenta obter a abreviação correta do mês
                                        for (const [abbrev, name] of Object.entries(monthNameMap)) {
                                            if (name.toLowerCase() === contest.mesDaSorte.toLowerCase()) {
                                                mesSorte = abbrev;
                                                break;
                                            }
                                        }
                                    }
                                    
                                    // Se não encontrou uma abreviação, use o nome completo
                                    if (!mesSorte && contest.mesDaSorte) {
                                        mesSorte = contest.mesDaSorte;
                                    }
                                    
                                    return `${contest.dezenas.join(' ')}${mesSorte ? ' ' + mesSorte : ''}`;
                                }).join('\n');
                                
                                // Salvar no cache
                                LOCAL_CACHE.setCached(cacheKey, formattedResults, 60 * 24); // 24 horas
                                
                                apiStatusContent.innerHTML += `<br>✅ Sucesso! Obtidos ${data.length} resultados da API Heroku.`;
                                document.getElementById('historicalResults').value = formattedResults;
                                analyzeFrequency(); // Analisar os dados obtidos
                                spinner.classList.add('hidden');
                                return;
                            }
                        }
                    } catch (error) {
                        apiStatusContent.innerHTML += `<br>❌ Falha na API Heroku: ${error.message}`;
                    }
                    
                    // Se a API Heroku falhar, tentar a API Brasil
                    apiStatusContent.innerHTML += '<br>Tentando buscar dados completos da API Brasil...';
                    
                    try {
                        const response = await fetch(API_CONFIG.BRASIL_URL, {
                            method: 'GET',
                            headers: { 
                                'Accept': 'application/json',
                                'Cache-Control': 'no-cache, no-store, must-revalidate'
                            },
                            cache: 'no-store' // Força o navegador a ignorar o cache
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            if (data && data.concursos && Array.isArray(data.concursos)) {
                                // Processar os resultados
                                const formattedResults = data.concursos.map(contest => {
                                    // Esta API não tem o mês da sorte, então vamos deixar em branco
                                    return contest.numeros.join(' ');
                                }).join('\n');
                                
                                // Salvar no cache
                                LOCAL_CACHE.setCached(cacheKey, formattedResults, 60 * 24); // 24 horas
                                
                                apiStatusContent.innerHTML += `<br>✅ Sucesso! Obtidos ${data.concursos.length} resultados da API Brasil.`;
                                document.getElementById('historicalResults').value = formattedResults;
                                analyzeFrequency(); // Analisar os dados obtidos
                                spinner.classList.add('hidden');
                                return;
                            }
                        }
                    } catch (error) {
                        apiStatusContent.innerHTML += `<br>❌ Falha na API Brasil: ${error.message}`;
                    }
                    
                    // Se ambas as APIs falharam, tentar obter todos os concursos da CAIXA
                    apiStatusContent.innerHTML += '<br>Tentando buscar o último concurso para identificar a quantidade total...';
                    
                    try {
                        // Primeiro, buscar o último concurso para saber até onde ir
                        const response = await fetch(API_CONFIG.CAIXA_URL, {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json',
                                'Content-Type': 'application/json',
                                'User-Agent': 'Mozilla/5.0',
                                'Cache-Control': 'no-cache, no-store, must-revalidate'
                            },
                            cache: 'no-store' // Força o navegador a ignorar o cache
                        });
                        
                        if (response.ok) {
                            const latestData = await response.json();
                            if (latestData && latestData.numero) {
                                const totalConcursos = latestData.numero;
                                apiStatusContent.innerHTML += `<br>✅ Identificado o último concurso: ${totalConcursos}`;
                                
                                // Adicionar o último concurso à lista
                                let allResults = [];
                                let mesAbbr = '';
                                
                                if (latestData.nomeMesDaSorte) {
                                    // Tenta obter a abreviação correta do mês
                                    for (const [abbrev, name] of Object.entries(monthNameMap)) {
                                        if (name.toLowerCase() === latestData.nomeMesDaSorte.toLowerCase()) {
                                            mesAbbr = abbrev;
                                            break;
                                        }
                                    }
                                }
                                
                                allResults.push(`${latestData.listaDezenas.join(' ')}${mesAbbr ? ' ' + mesAbbr : ''}`);
                                
                                // Buscar concursos anteriores (limitado a 300 para não sobrecarregar)
                                const maxConcursos = Math.min(totalConcursos, 300);
                                apiStatusContent.innerHTML += `<br>Buscando ${maxConcursos} concursos anteriores...`;
                                
                                for (let i = totalConcursos - 1; i >= 1; i--) {
                                    apiStatusContent.innerHTML = `Buscando concurso ${i} de ${totalConcursos}...`;
                                    
                                    try {
                                        const concursoResponse = await fetch(`${API_CONFIG.CAIXA_URL}/${i}`, {
                                            method: 'GET',
                                            headers: {
                                                'Accept': 'application/json',
                                                'Content-Type': 'application/json',
                                                'User-Agent': 'Mozilla/5.0',
                                                'Cache-Control': 'no-cache, no-store, must-revalidate'
                                            },
                                            cache: 'no-store' // Força o navegador a ignorar o cache
                                        });
                                        
                                        if (concursoResponse.ok) {
                                            const concursoData = await concursoResponse.json();
                                            if (concursoData && concursoData.listaDezenas) {
                                                let mesAbbr = '';
                                                
                                                if (concursoData.nomeMesDaSorte) {
                                                    // Tenta obter a abreviação correta do mês
                                                    for (const [abbrev, name] of Object.entries(monthNameMap)) {
                                                        if (name.toLowerCase() === concursoData.nomeMesDaSorte.toLowerCase()) {
                                                            mesAbbr = abbrev;
                                                            break;
                                                        }
                                                    }
                                                }
                                                
                                                allResults.push(`${concursoData.listaDezenas.join(' ')}${mesAbbr ? ' ' + mesAbbr : ''}`);
                                            }
                                        }
                                        
                                        // Pequena pausa para não sobrecarregar a API
                                        await new Promise(resolve => setTimeout(resolve, 300));
                                        
                                    } catch (concursoError) {
                                        apiStatusContent.innerHTML += `<br>Erro ao buscar concurso ${i}: ${concursoError.message}`;
                                        // Continuar mesmo se houver erro em um concurso específico
                                    }
                                }
                                
                                const formattedResults = allResults.join('\n');
                                
                                // Salvar no cache
                                LOCAL_CACHE.setCached(cacheKey, formattedResults, 60 * 24); // 24 horas
                                
                                apiStatusContent.innerHTML += `<br>✅ Sucesso! Obtidos ${allResults.length} resultados da API da Caixa.`;
                                document.getElementById('historicalResults').value = formattedResults;
                                analyzeFrequency(); // Analisar os dados obtidos
                                spinner.classList.add('hidden');
                                return;
                            }
                        }
                    } catch (error) {
                        apiStatusContent.innerHTML += `<br>❌ Falha na API da Caixa: ${error.message}`;
                    }
                    
                    // Se chegou aqui, todas as tentativas falharam
                    apiStatusContent.innerHTML += '<br>❌ Todas as tentativas de buscar os dados falharam.';
                    apiStatusContent.innerHTML += '<br>Por favor, tente novamente mais tarde ou insira os dados manualmente.';
                } catch (error) {
                    apiStatusContent.innerHTML += `<br>❌ Erro geral: ${error.message}`;
                } finally {
                    spinner.classList.add('hidden');
                }
            }

            // Add event listener for analyze button
            document.getElementById('analyzeBtn').addEventListener('click', analyzeFrequency);
            
            // ======== FUNÇÕES DE ACESSO À API ========
            
            // Função genérica para tentar acessar uma URL via múltiplos proxies CORS
            async function fetchViaProxy(baseUrl, customHeaders = {}) {
                // Cria uma cópia do array de proxies para tentar cada um
                const proxiesToTry = [...API_CONFIG.CORS_PROXY_URLS];
                
                // Vamos tentar cada proxy na lista, em ordem aleatória para distribuir o tráfego
                shuffleArray(proxiesToTry);
                
                // Tenta cada proxy disponível
                for (const proxyUrl of proxiesToTry) {
                    try {
                        // Constrói a URL com o proxy
                        const url = proxyUrl.includes('?url=') ? 
                            `${proxyUrl}${encodeURIComponent(baseUrl)}` : 
                            `${proxyUrl}${baseUrl}`;
                        
                        console.log(`Tentando via proxy: ${url}`);
                        
                        const response = await fetch(url, {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json',
                                'Cache-Control': 'no-cache, no-store, must-revalidate',
                                ...customHeaders
                            },
                            mode: 'cors',
                            cache: 'no-store' // Força o navegador a ignorar o cache
                        });
                        
                        if (response.ok) {
                            return await response.json();
                        }
                    } catch (proxyError) {
                        console.log(`Proxy falhou (${proxyUrl}):`, proxyError);
                        // Continua para o próximo proxy
                    }
                }
                
                throw new Error('Nenhum proxy CORS conseguiu acessar a URL');
            }

            // ===== API CAIXA =====
            async function fetchFromCaixaAPI(concursoNum = null, useProxy = false) {
                // Verificar se o usuário quer forçar a atualização
                const forceRefresh = document.getElementById('forceRefresh').checked;
                
                try {
                    // Verificar cache primeiro (se não estiver forçando atualização)
                    const cacheKey = concursoNum ? 
                        `caixa_dia_de_sorte_${concursoNum}` : 
                        'caixa_dia_de_sorte_latest';
                    
                    // Só buscar do cache se não estiver forçando atualização
                    if (!forceRefresh) {
                        const cachedData = LOCAL_CACHE.getCached(cacheKey);
                        
                        if (cachedData) {
                            console.log('Usando dados em cache para:', cacheKey);
                            return {
                                success: true,
                                message: `Sucesso! Dados obtidos do cache local (${cachedData.length} concursos).`,
                                formattedResults: cachedData.join('\n'),
                                source: 'cache'
                            };
                        }
                    } else {
                        // Se forçar atualização, remover o cache
                        LOCAL_CACHE.removeCache(cacheKey);
                    }
                    
                    // Constrói a URL baseada no parâmetro de concurso
                    const url = concursoNum ? 
                        `${API_CONFIG.CAIXA_URL}/${concursoNum}` : 
                        API_CONFIG.CAIXA_URL;
                    
                    let data;
                    
                    if (useProxy) {
                        // Acesso via proxy CORS
                        console.log(`Buscando dados da Caixa via proxy: ${url}`);
                        data = await fetchViaProxy(url, {
                            'Origin': 'https://loterias.caixa.gov.br',
                            'Referer': 'https://loterias.caixa.gov.br/'
                        });
                    } else {
                        // Acesso direto
                        console.log(`Buscando dados da Caixa diretamente: ${url}`);
                        const response = await fetch(url, {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json',
                                'Content-Type': 'application/json',
                                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                                'Origin': 'https://loterias.caixa.gov.br',
                                'Referer': 'https://loterias.caixa.gov.br/',
                                'Cache-Control': 'no-cache, no-store, must-revalidate'
                            },
                            mode: 'cors',
                            credentials: 'omit',
                            cache: 'no-store' // Força o navegador a ignorar o cache
                        });
                        
                        if (!response.ok) {
                            throw new Error(`Status HTTP: ${response.status}`);
                        }
                        
                        data = await response.json();
                    }
                    
                    console.log("Resposta da API Caixa:", data);
                    
                    // Extrair o mês da sorte (nome do mês + data)
                    let mesSorte = '';
                    if (data && data.nomeMesDaSorte) {
                        // Tenta obter o mês da sorte
                        mesSorte = data.nomeMesDaSorte;
                        
                        // Tenta transformar em uma abreviação de 3 letras
                        for (const [abbrev, name] of Object.entries(monthNameMap)) {
                            if (name.toLowerCase() === mesSorte.toLowerCase()) {
                                mesSorte = abbrev;
                                break;
                            }
                        }
                    }
                    
                    if (data && data.listaDezenas && Array.isArray(data.listaDezenas)) {
                        // Adiciona o mês da sorte no final, se disponível
                        const resultWithMonth = mesSorte ? 
                            `${data.listaDezenas.join(' ')} ${mesSorte}` : 
                            data.listaDezenas.join(' ');
                            
                        const allResults = [resultWithMonth];
                        
                        // Salvar no cache (se não estiver forçando atualização)
                        if (!forceRefresh) {
                            LOCAL_CACHE.setCached(cacheKey, allResults, 60); // Cache por 60 minutos
                        }
                        
                        return {
                            success: true,
                            message: `Sucesso! Dados obtidos em tempo real da API oficial da Caixa (concurso ${data.numero}) ${useProxy ? 'via proxy' : 'diretamente'}.`,
                            formattedResults: allResults.join('\n'),
                            source: useProxy ? 'caixa-proxy' : 'caixa'
                        };
                    } else {
                        throw new Error('Formato de dados inválido ou inesperado');
                    }
                } catch (error) {
                    console.error(`Erro ao acessar API Caixa ${useProxy ? 'via proxy' : 'diretamente'}:`, error);
                    return {
                        success: false,
                        message: `Falha na API Caixa ${useProxy ? '(via proxy)' : '(acesso direto)'}: ${error.message}`
                    };
                }
            }
            
            // ===== API HEROKU =====
            async function fetchFromHerokuAPI(useProxy = false) {
                // Verificar se o usuário quer forçar a atualização
                const forceRefresh = document.getElementById('forceRefresh').checked;
                
                try {
                    // Verificar cache primeiro (se não estiver forçando atualização)
                    const cacheKey = 'heroku_dia_de_sorte';
                    
                    // Só buscar do cache se não estiver forçando atualização
                    if (!forceRefresh) {
                        const cachedData = LOCAL_CACHE.getCached(cacheKey);
                        
                        if (cachedData) {
                            console.log('Usando dados em cache para Heroku API');
                            return {
                                success: true,
                                message: 'Sucesso! Dados obtidos do cache local (API Heroku).',
                                formattedResults: cachedData,
                                source: 'cache'
                            };
                        }
                    } else {
                        // Se forçar atualização, remover o cache
                        LOCAL_CACHE.removeCache(cacheKey);
                    }
                    
                    let data;
                    
                    if (useProxy) {
                        // Acesso via proxy CORS
                        console.log(`Buscando dados da Heroku API via proxy`);
                        data = await fetchViaProxy(API_CONFIG.HEROKU_URL);
                    } else {
                        // Acesso direto  
                        console.log(`Buscando dados da Heroku API diretamente`);
                        const response = await fetch(API_CONFIG.HEROKU_URL, {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json',
                                'Cache-Control': 'no-cache, no-store, must-revalidate'
                            },
                            cache: 'no-store' // Força o navegador a ignorar o cache
                        });
                        
                        if (!response.ok) {
                            throw new Error(`Status ${response.status}`);
                        }
                        
                        data = await response.json();
                    }
                    
                    console.log("Resposta da API Heroku:", data);
                    
                    if (data && Array.isArray(data)) {
                        const formattedResults = data.map(contest => {
                            // Tenta obter o mês da sorte
                            let mesSorte = '';
                            if (contest.mesDaSorte) {
                                // Converte para a abreviação usada no app
                                for (const [abbrev, name] of Object.entries(monthNameMap)) {
                                    if (name.toLowerCase() === contest.mesDaSorte.toLowerCase()) {
                                        mesSorte = abbrev;
                                        break;
                                    }
                                }
                            }
                            
                            // Adiciona o mês da sorte no final, se disponível
                            return mesSorte ? 
                                `${contest.dezenas.join(' ')} ${mesSorte}` : 
                                contest.dezenas.join(' ');
                        }).join('\n');
                        
                        // Armazenar em cache (se não estiver forçando atualização)
                        if (!forceRefresh) {
                            LOCAL_CACHE.setCached(cacheKey, formattedResults, 60); // Cache por 60 minutos
                        }
                        
                        return {
                            success: true,
                            message: `Sucesso! Dados obtidos em tempo real da API Heroku (${data.length} concursos) ${useProxy ? 'via proxy' : 'diretamente'}.`,
                            formattedResults: formattedResults,
                            source: useProxy ? 'heroku-proxy' : 'heroku'
                        };
                    } else {
                        throw new Error('Formato de dados inválido');
                    }
                } catch (error) {
                    console.error(`Erro ao acessar API Heroku ${useProxy ? 'via proxy' : 'diretamente'}:`, error);
                    return {
                        success: false,
                        message: `Falha na API Heroku ${useProxy ? '(via proxy)' : '(acesso direto)'}: ${error.message}`
                    };
                }
            }
            
            // ===== API BRASIL =====
            async function fetchFromBrasilAPI(useProxy = false) {
                // Verificar se o usuário quer forçar a atualização
                const forceRefresh = document.getElementById('forceRefresh').checked;
                
                try {
                    // Verificar cache primeiro (se não estiver forçando atualização)
                    const cacheKey = 'brasil_dia_de_sorte';
                    
                    // Só buscar do cache se não estiver forçando atualização
                    if (!forceRefresh) {
                        const cachedData = LOCAL_CACHE.getCached(cacheKey);
                        
                        if (cachedData) {
                            console.log('Usando dados em cache para Brasil API');
                            return {
                                success: true,
                                message: 'Sucesso! Dados obtidos do cache local (API Brasil).',
                                formattedResults: cachedData,
                                source: 'cache'
                            };
                        }
                    } else {
                        // Se forçar atualização, remover o cache
                        LOCAL_CACHE.removeCache(cacheKey);
                    }
                    
                    let data;
                    
                    if (useProxy) {
                        // Acesso via proxy CORS
                        console.log(`Buscando dados da Brasil API via proxy`);
                        data = await fetchViaProxy(API_CONFIG.BRASIL_URL);
                    } else {
                        // Acesso direto
                        console.log(`Buscando dados da Brasil API diretamente`);
                        const response = await fetch(API_CONFIG.BRASIL_URL, {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json',
                                'Cache-Control': 'no-cache, no-store, must-revalidate'
                            },
                            cache: 'no-store' // Força o navegador a ignorar o cache
                        });
                        
                        if (!response.ok) {
                            throw new Error(`Status ${response.status}`);
                        }
                        
                        data = await response.json();
                    }
                    
                    console.log("Resposta da API Brasil:", data);
                    
                    if (data && data.concursos && Array.isArray(data.concursos)) {
                        // A API Brasil não parece ter o mês da sorte, então adicionamos um aleatório
                        // apenas para demonstração
                        const months = Object.keys(monthFrequency);
                        
                        const formattedResults = data.concursos.map(contest => {
                            const randomMonth = months[Math.floor(Math.random() * months.length)];
                            return `${contest.numeros.join(' ')} ${randomMonth}`;
                        }).join('\n');
                        
                        // Armazenar em cache (se não estiver forçando atualização)
                        if (!forceRefresh) {
                            LOCAL_CACHE.setCached(cacheKey, formattedResults, 60);
                        }
                        
                        return {
                            success: true,
                            message: `Sucesso! Dados obtidos em tempo real da API Brasil (${data.concursos.length} concursos) ${useProxy ? 'via proxy' : 'diretamente'}.`,
                            formattedResults: formattedResults,
                            source: useProxy ? 'brasil-proxy' : 'brasil'
                        };
                    } else {
                        throw new Error('Formato de dados inválido');
                    }
                } catch (error) {
                    console.error(`Erro ao acessar API Brasil ${useProxy ? 'via proxy' : 'diretamente'}:`, error);
                    return {
                        success: false,
                        message: `Falha na API Brasil ${useProxy ? '(via proxy)' : '(acesso direto)'}: ${error.message}`
                    };
                }
            }
            
            // Função principal para buscar resultados de acordo com as configurações do usuário
            async function fetchResultsFromAPIs() {
                const spinner = document.getElementById('loadingSpinner');
                const fetchText = document.getElementById('fetchText');
                const apiStatus = document.getElementById('apiStatus');
                const apiStatusContent = document.getElementById('apiStatusContent');
                const apiSelect = document.getElementById('apiSelect');
                const modeSelect = document.getElementById('modeSelect');
                const forceRefresh = document.getElementById('forceRefresh').checked;
                
                const selectedAPI = apiSelect.value;
                const accessMode = modeSelect.value; // direct, proxy, or both
                
                // Obter o número do concurso (se fornecido)
                const concursoInput = document.getElementById('concursoNum');
                const concursoNum = concursoInput.value ? parseInt(concursoInput.value) : null;
                
                // Show loading spinner and status
                spinner.classList.remove('hidden');
                fetchText.textContent = 'Buscando...';
                apiStatus.classList.remove('hidden');
                apiStatusContent.innerHTML = `Iniciando busca de resultados ${forceRefresh ? "(atualizando cache)" : ""}...`;
                
                if (concursoNum) {
                    apiStatusContent.innerHTML += `<br>Buscando dados do concurso ${concursoNum}...`;
                }
                
                // Clear any previous results
                document.getElementById('historicalResults').value = '';
                
                try {
                    // Se uma API específica foi selecionada
                    if (selectedAPI !== 'auto') {
                        apiStatusContent.innerHTML += `<br>API selecionada: ${selectedAPI}`;
                        
                        let result = null;
                        
                        // Tenta obter dados de acordo com o modo selecionado
                        if (accessMode === 'direct' || accessMode === 'both') {
                            apiStatusContent.innerHTML += '<br>Tentando acesso direto...';
                            
                            switch (selectedAPI) {
                                case 'caixa':
                                    result = await fetchFromCaixaAPI(concursoNum, false);
                                    break;
                                case 'heroku':
                                    result = await fetchFromHerokuAPI(false);
                                    break;
                                case 'brasilapi':
                                    result = await fetchFromBrasilAPI(false);
                                    break;
                            }
                            
                            if (result && result.success) {
                                apiStatusContent.innerHTML += `<br>✅ ${result.message}`;
                                document.getElementById('historicalResults').value = result.formattedResults;
                                analyzeFrequency();
                                
                                spinner.classList.add('hidden');
                                fetchText.textContent = 'Buscar Resultados';
                                return;
                            } else if (result) {
                                apiStatusContent.innerHTML += `<br>❌ ${result.message}`;
                            }
                        }
                        
                        // Se o modo direto falhou ou foi pulado, tenta via proxy
                        if (accessMode === 'proxy' || accessMode === 'both') {
                            apiStatusContent.innerHTML += '<br>Tentando acesso via proxy CORS...';
                            
                            switch (selectedAPI) {
                                case 'caixa':
                                    result = await fetchFromCaixaAPI(concursoNum, true);
                                    break;
                                case 'heroku':
                                    result = await fetchFromHerokuAPI(true);
                                    break;
                                case 'brasilapi':
                                    result = await fetchFromBrasilAPI(true);
                                    break;
                            }
                            
                            if (result && result.success) {
                                apiStatusContent.innerHTML += `<br>✅ ${result.message}`;
                                document.getElementById('historicalResults').value = result.formattedResults;
                                analyzeFrequency();
                                
                                spinner.classList.add('hidden');
                                fetchText.textContent = 'Buscar Resultados';
                                return;
                            } else if (result) {
                                apiStatusContent.innerHTML += `<br>❌ ${result.message}`;
                            }
                        }
                        
                        // Se chegou aqui, todas as tentativas falharam
                        apiStatusContent.innerHTML += '<br>❌ Todas as tentativas falharam para a API selecionada.';
                        apiStatusContent.innerHTML += '<br>⚠️ Tente outra API ou modifique os parâmetros da busca.';
                    } else {
                        // Modo automático - tenta todas as APIs
                        apiStatusContent.innerHTML += '<br>Modo automático: testando múltiplas APIs...';
                        
                        // Array com todas as combinações de API e modo de acesso para tentar
                        const apiOptions = [
                            // Primeiro tenta Heroku (geralmente mais confiável)
                            { name: 'heroku', fn: fetchFromHerokuAPI, params: [false], label: 'Heroku (direto)' },
                            { name: 'heroku', fn: fetchFromHerokuAPI, params: [true], label: 'Heroku (proxy)' },
                            
                            // Depois Caixa
                            { name: 'caixa', fn: fetchFromCaixaAPI, params: [concursoNum, false], label: 'Caixa (direto)' },
                            { name: 'caixa', fn: fetchFromCaixaAPI, params: [concursoNum, true], label: 'Caixa (proxy)' },
                            
                            // Por último Brasil
                            { name: 'brasilapi', fn: fetchFromBrasilAPI, params: [false], label: 'Brasil (direto)' },
                            { name: 'brasilapi', fn: fetchFromBrasilAPI, params: [true], label: 'Brasil (proxy)' }
                        ];
                        
                        // Tentar cada combinação de API e modo de acesso
                        for (const option of apiOptions) {
                            apiStatusContent.innerHTML += `<br>Tentando API ${option.label}...`;
                            
                            try {
                                const result = await option.fn(...option.params);
                                
                                if (result.success) {
                                    apiStatusContent.innerHTML += `<br>✅ ${result.message}`;
                                    document.getElementById('historicalResults').value = result.formattedResults;
                                    analyzeFrequency();
                                    
                                    spinner.classList.add('hidden');
                                    fetchText.textContent = 'Buscar Resultados';
                                    return;
                                } else {
                                    apiStatusContent.innerHTML += `<br>❌ ${result.message}`;
                                }
                            } catch (apiError) {
                                apiStatusContent.innerHTML += `<br>❌ Erro inesperado: ${apiError.message}`;
                            }
                        }
                        
                        // Se chegou aqui, todas as APIs falharam
                        apiStatusContent.innerHTML += '<br>❌ Todas as APIs falharam.';
                        apiStatusContent.innerHTML += '<br>⚠️ Sugestões:';
                        apiStatusContent.innerHTML += '<br>1. Verifique sua conexão com a internet';
                        apiStatusContent.innerHTML += '<br>2. Tente novamente mais tarde';
                        apiStatusContent.innerHTML += '<br>3. Insira manualmente os resultados da loteria';
                    }
                } catch (error) {
                    apiStatusContent.innerHTML += `<br>❌ Erro geral: ${error.message}`;
                    apiStatusContent.innerHTML += '<br>⚠️ Por favor, tente novamente ou insira os dados manualmente.';
                } finally {
                    spinner.classList.add('hidden');
                    fetchText.textContent = 'Buscar Resultados';
                    frequencySection.updateHeight();
                }
            }
            
            // Add event listener for fetching results
            document.getElementById('fetchResultsBtn').addEventListener('click', fetchResultsFromAPIs);
            document.getElementById('fetchAllResultsBtn').addEventListener('click', fetchAllHistoricalResults);

            // Configurar a distribuição por faixa
            setupRangeDistribution();
            
            // Configurar botão para gerar resultados
            document.getElementById('generateBtn').addEventListener('click', generateResults);

            // Configurar botão para imprimir resultados
            document.getElementById('printBtn').addEventListener('click', function() {
                window.print();
            });
            
            // Configurar download de botões
            document.getElementById('downloadSimpleBtn').addEventListener('click', downloadSimpleBets);
            document.getElementById('downloadBtn').addEventListener('click', downloadBets);
            document.getElementById('downloadUndrawnBtn').addEventListener('click', downloadUndrawnCombinations);
            document.getElementById('downloadSpecificBtn').addEventListener('click', downloadSpecificBets);
            document.getElementById('downloadSpecificSimpleBtn').addEventListener('click', downloadSpecificSimpleBets);
            
            // Configurar botão para gerar palpites específicos
            document.getElementById('generateSpecificBtn').addEventListener('click', generateSpecificBets);
            
            // Configurar navegação de paginação
            document.getElementById('prevPageBtn').addEventListener('click', function() {
                if (currentPage > 1) {
                    currentPage--;
                    setupPagination();
                }
            });
            
            document.getElementById('nextPageBtn').addEventListener('click', function() {
                const totalPages = Math.ceil(specificGeneratedBets.length / itemsPerPage);
                if (currentPage < totalPages) {
                    currentPage++;
                    setupPagination();
                }
            });

            // Inicializar com os dados padrão
            specificComboSelect.addEventListener('change', updatePossibleNumbers);
            updatePossibleNumbers();
            setupTabs();
        });
    </script>
    
    <footer>Feito por: <i>Márcio Fernando Maia -  Todos os direitos reservado - 2025</i></footer>
</body>

<!--
Temos 7 seções vou solicitar ajuste para algumas delas esta por ordem de prioridade


1 - Análise de Frequência de Resultados Anteriores              - focar nesta seção ela é a mais importante - Deixar apenas o botão BUSCAR RESULTADOS (e trazer todos os resultados) do primeiro ao ultimo - tirar o botão buscar todos e tbm a opção Forçar atualização (ignorar cache) lembrando que antes.. estava trazendo todos os resultados usando a api oficial da caixa usando proxy e cors - faça uma pesquisa anterior que vc vai ver que estava fucioando
2 - Resumo Estatístico                                                             - poderia destacar os items que estão entre parentes - (40) conjuntos de dígitos geram (9) números
3 - Gerador por Combinação Específica                                 - alem de marcar os digitos [Não sorteados] 0,1,2,3,4, tbm preciso que seja mostrado os digitos que ja foram sorteados (o usuario pode querer utilizar elas para gerar combinações)
4 - Combinações de Dígitos  (126)                                         - alterar o lay out  - vizualização (imagen anexa)
5 - Configurações                                                                   - alterar o lay out  - vizualização (imagen anexa)
6 - Palpites Gerados (126 palpites)                                         - ok nada a alterar
7 - Tabela de Combinações                                                     - ok nada a alterar



Temos 7 seções vou solicitar ajuste para algumas delas esta por ordem de prioridade


1 - Análise de Frequência de Resultados Anteriores              - atendio sim ou não.
2 - Resumo Estatístico                                                             - atendio sim ou não.
3 - Gerador por Combinação Específica                                 - atendio sim ou não.
4 - Combinações de Dígitos  (126)                                         - atendio sim ou não.
5 - Configurações                                                                   - atendio sim ou não.
6 - Palpites Gerados (126 palpites)                                         - ok nada a alterar
7 - Tabela de Combinações                                                     - ok nada a alterar
-->


</html>